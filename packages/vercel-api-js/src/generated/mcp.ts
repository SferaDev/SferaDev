/**
 * Generated by Kubb (https://kubb.dev/).
 * Do not edit manually.
 */

import type { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import {
	acceptProjectTransferRequest,
	addBypassIp,
	addProjectDomain,
	addProjectMember,
	approveRollingReleaseStage,
	artifactQuery,
	assignAlias,
	batchRemoveProjectEnv,
	buyDomains,
	buySingleDomain,
	cancelDeployment,
	completeRollingRelease,
	connectIntegrationResourceToProject,
	createAccessGroup,
	createAccessGroupProject,
	createAuthToken,
	createCheck,
	createConfigurableLogDrain,
	createCustomEnvironment,
	createDeployment,
	createDrain,
	createEdgeConfig,
	createEdgeConfigToken,
	createEvent,
	createExperimentationItem,
	createIntegrationStoreDirect,
	createLogDrain,
	createNetwork,
	createOrTransferDomain,
	createProject,
	createProjectEnv,
	createProjectTransferRequest,
	createRecord,
	createSharedEnvVariable,
	createTeam,
	createWebhook,
	dangerouslyDeleteBySrcImages,
	dangerouslyDeleteByTags,
	deleteAccessGroup,
	deleteAccessGroupProject,
	deleteAlias,
	deleteAuthToken,
	deleteConfigurableLogDrain,
	deleteConfiguration,
	deleteDeployment,
	deleteDomain,
	deleteDrain,
	deleteEdgeConfig,
	deleteEdgeConfigSchema,
	deleteEdgeConfigTokens,
	deleteExperimentationItem,
	deleteIntegrationLogDrain,
	deleteIntegrationResource,
	deleteNetwork,
	deleteProject,
	deleteRedirects,
	deleteRollingReleaseConfig,
	deleteSharedEnvVariable,
	deleteTeam,
	deleteTeamInviteCode,
	deleteWebhook,
	downloadArtifact,
	editProjectEnv,
	editRedirect,
	exchangeSsoToken,
	filterProjectEnvs,
	gETV1BillingCharges,
	gETV1BillingContractCommitments,
	gETV1InstallationsIntegrationConfigurationIdResourcesResourceIdExperimentationEdgeConfig,
	gETV1SecurityFirewallEvents,
	getAccountInfo,
	getActiveAttackStatus,
	getAlias,
	getAllChecks,
	getAllLogDrains,
	getAuthToken,
	getAuthUser,
	getBillingPlans,
	getBulkAvailability,
	getBypassIp,
	getCertById,
	getCheck,
	getConfigurableLogDrain,
	getConfiguration,
	getConfigurationProducts,
	getConfigurations,
	getContactInfoSchema,
	getCustomEnvironment,
	getDeployment,
	getDeploymentEvents,
	getDeploymentFileContents,
	getDeployments,
	getDomain,
	getDomainAuthCode,
	getDomainAvailability,
	getDomainConfig,
	getDomainPrice,
	getDomains,
	getDomainTransferIn,
	getDrain,
	getDrains,
	getEdgeConfig,
	getEdgeConfigBackup,
	getEdgeConfigBackups,
	getEdgeConfigItem,
	getEdgeConfigItems,
	getEdgeConfigSchema,
	getEdgeConfigs,
	getEdgeConfigToken,
	getEdgeConfigTokens,
	getFirewallConfig,
	getIntegrationLogDrains,
	getIntegrationResource,
	getIntegrationResources,
	getInvoice,
	getMember,
	getOrder,
	getProject,
	getProjectDomain,
	getProjectDomains,
	getProjectEnv,
	getProjectMembers,
	getProjects,
	getRecords,
	getRedirects,
	getRollingRelease,
	getRollingReleaseBillingStatus,
	getRollingReleaseConfig,
	getRuntimeLogs,
	getSharedEnvVar,
	getSupportedTlds,
	getTeam,
	getTeamAccessRequest,
	getTeamMembers,
	getTeams,
	getTldPrice,
	getVersions,
	getWebhook,
	getWebhooks,
	gitNamespaces,
	importResource,
	invalidateBySrcImages,
	invalidateByTags,
	inviteUserToTeam,
	issueCert,
	joinTeam,
	listAccessGroupMembers,
	listAccessGroupProjects,
	listAccessGroups,
	listAliases,
	listAuthTokens,
	listCustomEnvironments,
	listDeploymentAliases,
	listDeploymentFiles,
	listNetworks,
	listPromoteAliases,
	listSharedEnvVariable,
	listUserEvents,
	moveProjectDomain,
	pATCHV1ProjectsProjectIdRollbackDeploymentIdUpdateDescription,
	patchDomain,
	patchEdgeConfigItems,
	patchEdgeConfigSchema,
	patchTeam,
	patchUrlProtectionBypass,
	pauseProject,
	postTeamDsyncRoles,
	putFirewallConfig,
	readAccessGroup,
	readAccessGroupProject,
	readNetwork,
	recordEvents,
	removeBypassIp,
	removeCert,
	removeCustomEnvironment,
	removeProjectDomain,
	removeProjectEnv,
	removeProjectMember,
	removeRecord,
	removeTeamMember,
	renewDomain,
	requestAccessToTeam,
	requestDelete,
	requestPromote,
	requestRollback,
	rerequestCheck,
	restoreRedirects,
	searchRepo,
	stageRedirects,
	status,
	submitBillingData,
	submitInvoice,
	submitPrepaymentBalances,
	testDrain,
	transferInDomain,
	unlinkSharedEnvVariable,
	unpauseProject,
	updateAccessGroup,
	updateAccessGroupProject,
	updateAttackChallengeMode,
	updateCheck,
	updateCustomEnvironment,
	updateDomainAutoRenew,
	updateDomainNameservers,
	updateDrain,
	updateEdgeConfig,
	updateExperimentationEdgeConfig,
	updateExperimentationItem,
	updateFirewallConfig,
	updateInstallation,
	updateIntegrationDeploymentAction,
	updateInvoice,
	updateNetwork,
	updateProject,
	updateProjectDomain,
	updateProjectProtectionBypass,
	updateRecord,
	updateResource,
	updateResourceSecrets,
	updateResourceSecretsById,
	updateRollingReleaseConfig,
	updateSharedEnvVariable,
	updateStaticIps,
	updateTeamMember,
	updateVersion,
	uploadArtifact,
	uploadCert,
	uploadFile,
	verifyProjectDomain,
} from "./components";
import {
	acceptProjectTransferRequestPathParamsSchema,
	acceptProjectTransferRequestQueryParamsSchema,
	addBypassIpQueryParamsSchema,
	addProjectDomainPathParamsSchema,
	addProjectDomainQueryParamsSchema,
	addProjectMemberPathParamsSchema,
	addProjectMemberQueryParamsSchema,
	approveRollingReleaseStagePathParamsSchema,
	approveRollingReleaseStageQueryParamsSchema,
	artifactQueryQueryParamsSchema,
	assignAliasPathParamsSchema,
	assignAliasQueryParamsSchema,
	batchRemoveProjectEnvPathParamsSchema,
	batchRemoveProjectEnvQueryParamsSchema,
	buyDomainsQueryParamsSchema,
	buySingleDomainPathParamsSchema,
	buySingleDomainQueryParamsSchema,
	cancelDeploymentPathParamsSchema,
	cancelDeploymentQueryParamsSchema,
	completeRollingReleasePathParamsSchema,
	completeRollingReleaseQueryParamsSchema,
	connectIntegrationResourceToProjectPathParamsSchema,
	connectIntegrationResourceToProjectQueryParamsSchema,
	createAccessGroupProjectPathParamsSchema,
	createAccessGroupProjectQueryParamsSchema,
	createAccessGroupQueryParamsSchema,
	createAuthTokenQueryParamsSchema,
	createCheckPathParamsSchema,
	createCheckQueryParamsSchema,
	createConfigurableLogDrainQueryParamsSchema,
	createCustomEnvironmentPathParamsSchema,
	createCustomEnvironmentQueryParamsSchema,
	createDeploymentQueryParamsSchema,
	createDrainQueryParamsSchema,
	createEdgeConfigQueryParamsSchema,
	createEdgeConfigTokenPathParamsSchema,
	createEdgeConfigTokenQueryParamsSchema,
	createEventPathParamsSchema,
	createExperimentationItemPathParamsSchema,
	createIntegrationStoreDirectQueryParamsSchema,
	createLogDrainQueryParamsSchema,
	createNetworkQueryParamsSchema,
	createOrTransferDomainQueryParamsSchema,
	createProjectEnvPathParamsSchema,
	createProjectEnvQueryParamsSchema,
	createProjectQueryParamsSchema,
	createProjectTransferRequestPathParamsSchema,
	createProjectTransferRequestQueryParamsSchema,
	createRecordPathParamsSchema,
	createRecordQueryParamsSchema,
	createSharedEnvVariableQueryParamsSchema,
	createWebhookQueryParamsSchema,
	dangerouslyDeleteBySrcImagesQueryParamsSchema,
	dangerouslyDeleteByTagsQueryParamsSchema,
	deleteAccessGroupPathParamsSchema,
	deleteAccessGroupProjectPathParamsSchema,
	deleteAccessGroupProjectQueryParamsSchema,
	deleteAccessGroupQueryParamsSchema,
	deleteAliasPathParamsSchema,
	deleteAliasQueryParamsSchema,
	deleteAuthTokenPathParamsSchema,
	deleteConfigurableLogDrainPathParamsSchema,
	deleteConfigurableLogDrainQueryParamsSchema,
	deleteConfigurationPathParamsSchema,
	deleteConfigurationQueryParamsSchema,
	deleteDeploymentPathParamsSchema,
	deleteDeploymentQueryParamsSchema,
	deleteDomainPathParamsSchema,
	deleteDomainQueryParamsSchema,
	deleteDrainPathParamsSchema,
	deleteDrainQueryParamsSchema,
	deleteEdgeConfigPathParamsSchema,
	deleteEdgeConfigQueryParamsSchema,
	deleteEdgeConfigSchemaPathParamsSchema,
	deleteEdgeConfigSchemaQueryParamsSchema,
	deleteEdgeConfigTokensPathParamsSchema,
	deleteEdgeConfigTokensQueryParamsSchema,
	deleteExperimentationItemPathParamsSchema,
	deleteIntegrationLogDrainPathParamsSchema,
	deleteIntegrationLogDrainQueryParamsSchema,
	deleteIntegrationResourcePathParamsSchema,
	deleteNetworkPathParamsSchema,
	deleteNetworkQueryParamsSchema,
	deleteProjectPathParamsSchema,
	deleteProjectQueryParamsSchema,
	deleteRedirectsQueryParamsSchema,
	deleteRollingReleaseConfigPathParamsSchema,
	deleteRollingReleaseConfigQueryParamsSchema,
	deleteSharedEnvVariableQueryParamsSchema,
	deleteTeamInviteCodePathParamsSchema,
	deleteTeamPathParamsSchema,
	deleteTeamQueryParamsSchema,
	deleteWebhookPathParamsSchema,
	deleteWebhookQueryParamsSchema,
	downloadArtifactHeaderParamsSchema,
	downloadArtifactPathParamsSchema,
	downloadArtifactQueryParamsSchema,
	editProjectEnvPathParamsSchema,
	editProjectEnvQueryParamsSchema,
	editRedirectQueryParamsSchema,
	filterProjectEnvsPathParamsSchema,
	filterProjectEnvsQueryParamsSchema,
	GETV1InstallationsIntegrationConfigurationIdResourcesResourceIdExperimentationEdgeConfigPathParamsSchema,
	GETV1SecurityFirewallEventsQueryParamsSchema,
	getAccountInfoPathParamsSchema,
	getActiveAttackStatusQueryParamsSchema,
	getAliasPathParamsSchema,
	getAliasQueryParamsSchema,
	getAllChecksPathParamsSchema,
	getAllChecksQueryParamsSchema,
	getAllLogDrainsQueryParamsSchema,
	getAuthTokenPathParamsSchema,
	getBillingPlansPathParamsSchema,
	getBillingPlansQueryParamsSchema,
	getBulkAvailabilityQueryParamsSchema,
	getBypassIpQueryParamsSchema,
	getCertByIdPathParamsSchema,
	getCertByIdQueryParamsSchema,
	getCheckPathParamsSchema,
	getCheckQueryParamsSchema,
	getConfigurableLogDrainPathParamsSchema,
	getConfigurableLogDrainQueryParamsSchema,
	getConfigurationPathParamsSchema,
	getConfigurationProductsPathParamsSchema,
	getConfigurationProductsQueryParamsSchema,
	getConfigurationQueryParamsSchema,
	getConfigurationsQueryParamsSchema,
	getContactInfoSchemaPathParamsSchema,
	getContactInfoSchemaQueryParamsSchema,
	getCustomEnvironmentPathParamsSchema,
	getCustomEnvironmentQueryParamsSchema,
	getDeploymentEventsPathParamsSchema,
	getDeploymentEventsQueryParamsSchema,
	getDeploymentFileContentsPathParamsSchema,
	getDeploymentFileContentsQueryParamsSchema,
	getDeploymentPathParamsSchema,
	getDeploymentQueryParamsSchema,
	getDeploymentsQueryParamsSchema,
	getDomainAuthCodePathParamsSchema,
	getDomainAuthCodeQueryParamsSchema,
	getDomainAvailabilityPathParamsSchema,
	getDomainAvailabilityQueryParamsSchema,
	getDomainConfigPathParamsSchema,
	getDomainConfigQueryParamsSchema,
	getDomainPathParamsSchema,
	getDomainPricePathParamsSchema,
	getDomainPriceQueryParamsSchema,
	getDomainQueryParamsSchema,
	getDomainsQueryParamsSchema,
	getDomainTransferInPathParamsSchema,
	getDomainTransferInQueryParamsSchema,
	getDrainPathParamsSchema,
	getDrainQueryParamsSchema,
	getDrainsQueryParamsSchema,
	getEdgeConfigBackupPathParamsSchema,
	getEdgeConfigBackupQueryParamsSchema,
	getEdgeConfigBackupsPathParamsSchema,
	getEdgeConfigBackupsQueryParamsSchema,
	getEdgeConfigItemPathParamsSchema,
	getEdgeConfigItemQueryParamsSchema,
	getEdgeConfigItemsPathParamsSchema,
	getEdgeConfigItemsQueryParamsSchema,
	getEdgeConfigPathParamsSchema,
	getEdgeConfigQueryParamsSchema,
	getEdgeConfigSchemaPathParamsSchema,
	getEdgeConfigSchemaQueryParamsSchema,
	getEdgeConfigsQueryParamsSchema,
	getEdgeConfigTokenPathParamsSchema,
	getEdgeConfigTokenQueryParamsSchema,
	getEdgeConfigTokensPathParamsSchema,
	getEdgeConfigTokensQueryParamsSchema,
	getFirewallConfigPathParamsSchema,
	getFirewallConfigQueryParamsSchema,
	getIntegrationLogDrainsQueryParamsSchema,
	getIntegrationResourcePathParamsSchema,
	getIntegrationResourcesPathParamsSchema,
	getInvoicePathParamsSchema,
	getMemberPathParamsSchema,
	getOrderPathParamsSchema,
	getOrderQueryParamsSchema,
	getProjectDomainPathParamsSchema,
	getProjectDomainQueryParamsSchema,
	getProjectDomainsPathParamsSchema,
	getProjectDomainsQueryParamsSchema,
	getProjectEnvPathParamsSchema,
	getProjectEnvQueryParamsSchema,
	getProjectMembersPathParamsSchema,
	getProjectMembersQueryParamsSchema,
	getProjectPathParamsSchema,
	getProjectQueryParamsSchema,
	getProjectsQueryParamsSchema,
	getRecordsPathParamsSchema,
	getRecordsQueryParamsSchema,
	getRedirectsQueryParamsSchema,
	getRollingReleaseBillingStatusPathParamsSchema,
	getRollingReleaseBillingStatusQueryParamsSchema,
	getRollingReleaseConfigPathParamsSchema,
	getRollingReleaseConfigQueryParamsSchema,
	getRollingReleasePathParamsSchema,
	getRollingReleaseQueryParamsSchema,
	getRuntimeLogsPathParamsSchema,
	getRuntimeLogsQueryParamsSchema,
	getSharedEnvVarPathParamsSchema,
	getSharedEnvVarQueryParamsSchema,
	getSupportedTldsQueryParamsSchema,
	getTeamAccessRequestPathParamsSchema,
	getTeamMembersPathParamsSchema,
	getTeamMembersQueryParamsSchema,
	getTeamPathParamsSchema,
	getTeamQueryParamsSchema,
	getTeamsQueryParamsSchema,
	getTldPricePathParamsSchema,
	getTldPriceQueryParamsSchema,
	getVersionsQueryParamsSchema,
	getWebhookPathParamsSchema,
	getWebhookQueryParamsSchema,
	getWebhooksQueryParamsSchema,
	gitNamespacesQueryParamsSchema,
	importResourcePathParamsSchema,
	invalidateBySrcImagesQueryParamsSchema,
	invalidateByTagsQueryParamsSchema,
	inviteUserToTeamPathParamsSchema,
	issueCertQueryParamsSchema,
	joinTeamPathParamsSchema,
	listAccessGroupMembersPathParamsSchema,
	listAccessGroupMembersQueryParamsSchema,
	listAccessGroupProjectsPathParamsSchema,
	listAccessGroupProjectsQueryParamsSchema,
	listAccessGroupsQueryParamsSchema,
	listAliasesQueryParamsSchema,
	listCustomEnvironmentsPathParamsSchema,
	listCustomEnvironmentsQueryParamsSchema,
	listDeploymentAliasesPathParamsSchema,
	listDeploymentAliasesQueryParamsSchema,
	listDeploymentFilesPathParamsSchema,
	listDeploymentFilesQueryParamsSchema,
	listNetworksQueryParamsSchema,
	listPromoteAliasesPathParamsSchema,
	listPromoteAliasesQueryParamsSchema,
	listSharedEnvVariableQueryParamsSchema,
	listUserEventsQueryParamsSchema,
	moveProjectDomainPathParamsSchema,
	moveProjectDomainQueryParamsSchema,
	PATCHV1ProjectsProjectIdRollbackDeploymentIdUpdateDescriptionPathParamsSchema,
	patchDomainPathParamsSchema,
	patchDomainQueryParamsSchema,
	patchEdgeConfigItemsPathParamsSchema,
	patchEdgeConfigItemsQueryParamsSchema,
	patchEdgeConfigSchemaPathParamsSchema,
	patchEdgeConfigSchemaQueryParamsSchema,
	patchTeamPathParamsSchema,
	patchTeamQueryParamsSchema,
	patchUrlProtectionBypassPathParamsSchema,
	patchUrlProtectionBypassQueryParamsSchema,
	pauseProjectPathParamsSchema,
	pauseProjectQueryParamsSchema,
	postTeamDsyncRolesPathParamsSchema,
	postTeamDsyncRolesQueryParamsSchema,
	putFirewallConfigQueryParamsSchema,
	readAccessGroupPathParamsSchema,
	readAccessGroupProjectPathParamsSchema,
	readAccessGroupProjectQueryParamsSchema,
	readAccessGroupQueryParamsSchema,
	readNetworkPathParamsSchema,
	readNetworkQueryParamsSchema,
	recordEventsHeaderParamsSchema,
	recordEventsQueryParamsSchema,
	removeBypassIpQueryParamsSchema,
	removeCertPathParamsSchema,
	removeCertQueryParamsSchema,
	removeCustomEnvironmentPathParamsSchema,
	removeCustomEnvironmentQueryParamsSchema,
	removeProjectDomainPathParamsSchema,
	removeProjectDomainQueryParamsSchema,
	removeProjectEnvPathParamsSchema,
	removeProjectEnvQueryParamsSchema,
	removeProjectMemberPathParamsSchema,
	removeProjectMemberQueryParamsSchema,
	removeRecordPathParamsSchema,
	removeRecordQueryParamsSchema,
	removeTeamMemberPathParamsSchema,
	removeTeamMemberQueryParamsSchema,
	renewDomainPathParamsSchema,
	renewDomainQueryParamsSchema,
	requestAccessToTeamPathParamsSchema,
	requestPromotePathParamsSchema,
	requestPromoteQueryParamsSchema,
	requestRollbackPathParamsSchema,
	requestRollbackQueryParamsSchema,
	rerequestCheckPathParamsSchema,
	rerequestCheckQueryParamsSchema,
	restoreRedirectsQueryParamsSchema,
	searchRepoQueryParamsSchema,
	stageRedirectsQueryParamsSchema,
	statusQueryParamsSchema,
	submitBillingDataPathParamsSchema,
	submitInvoicePathParamsSchema,
	submitPrepaymentBalancesPathParamsSchema,
	testDrainQueryParamsSchema,
	transferInDomainPathParamsSchema,
	transferInDomainQueryParamsSchema,
	unlinkSharedEnvVariablePathParamsSchema,
	unlinkSharedEnvVariableQueryParamsSchema,
	unpauseProjectPathParamsSchema,
	unpauseProjectQueryParamsSchema,
	updateAccessGroupPathParamsSchema,
	updateAccessGroupProjectPathParamsSchema,
	updateAccessGroupProjectQueryParamsSchema,
	updateAccessGroupQueryParamsSchema,
	updateAttackChallengeModeQueryParamsSchema,
	updateCheckPathParamsSchema,
	updateCheckQueryParamsSchema,
	updateCustomEnvironmentPathParamsSchema,
	updateCustomEnvironmentQueryParamsSchema,
	updateDomainAutoRenewPathParamsSchema,
	updateDomainAutoRenewQueryParamsSchema,
	updateDomainNameserversPathParamsSchema,
	updateDomainNameserversQueryParamsSchema,
	updateDrainPathParamsSchema,
	updateDrainQueryParamsSchema,
	updateEdgeConfigPathParamsSchema,
	updateEdgeConfigQueryParamsSchema,
	updateExperimentationEdgeConfigPathParamsSchema,
	updateExperimentationItemPathParamsSchema,
	updateFirewallConfigQueryParamsSchema,
	updateInstallationPathParamsSchema,
	updateIntegrationDeploymentActionPathParamsSchema,
	updateInvoicePathParamsSchema,
	updateNetworkPathParamsSchema,
	updateNetworkQueryParamsSchema,
	updateProjectDomainPathParamsSchema,
	updateProjectDomainQueryParamsSchema,
	updateProjectPathParamsSchema,
	updateProjectProtectionBypassPathParamsSchema,
	updateProjectProtectionBypassQueryParamsSchema,
	updateProjectQueryParamsSchema,
	updateRecordPathParamsSchema,
	updateRecordQueryParamsSchema,
	updateResourcePathParamsSchema,
	updateResourceSecretsByIdPathParamsSchema,
	updateResourceSecretsPathParamsSchema,
	updateRollingReleaseConfigPathParamsSchema,
	updateRollingReleaseConfigQueryParamsSchema,
	updateSharedEnvVariableQueryParamsSchema,
	updateStaticIpsPathParamsSchema,
	updateStaticIpsQueryParamsSchema,
	updateTeamMemberPathParamsSchema,
	updateVersionQueryParamsSchema,
	uploadArtifactHeaderParamsSchema,
	uploadArtifactPathParamsSchema,
	uploadArtifactQueryParamsSchema,
	uploadCertQueryParamsSchema,
	uploadFileHeaderParamsSchema,
	uploadFileQueryParamsSchema,
	verifyProjectDomainPathParamsSchema,
	verifyProjectDomainQueryParamsSchema,
} from "./schemas";

export function initMcpTools<Server>(serverLike: Server, config: FetcherConfig) {
	const server = serverLike as McpServer;

	server.tool(
		"readAccessGroup",
		"Allows to read an access group",
		{
			idOrName: readAccessGroupPathParamsSchema.shape["idOrName"],
			queryParams: readAccessGroupQueryParamsSchema,
		},
		async ({ idOrName, queryParams }) => {
			try {
				return await readAccessGroup({ pathParams: { idOrName }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"updateAccessGroup",
		"Allows to update an access group metadata",
		{
			idOrName: updateAccessGroupPathParamsSchema.shape["idOrName"],
			queryParams: updateAccessGroupQueryParamsSchema,
		},
		async ({ idOrName, queryParams }) => {
			try {
				return await updateAccessGroup({ pathParams: { idOrName }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"deleteAccessGroup",
		"Allows to delete an access group",
		{
			idOrName: deleteAccessGroupPathParamsSchema.shape["idOrName"],
			queryParams: deleteAccessGroupQueryParamsSchema,
		},
		async ({ idOrName, queryParams }) => {
			try {
				return await deleteAccessGroup({ pathParams: { idOrName }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"listAccessGroupMembers",
		"List members of an access group",
		{
			idOrName: listAccessGroupMembersPathParamsSchema.shape["idOrName"],
			queryParams: listAccessGroupMembersQueryParamsSchema,
		},
		async ({ idOrName, queryParams }) => {
			try {
				return await listAccessGroupMembers({ pathParams: { idOrName }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"listAccessGroups",
		"List access groups",
		{ queryParams: listAccessGroupsQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await listAccessGroups({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"createAccessGroup",
		"Allows to create an access group",
		{ queryParams: createAccessGroupQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await createAccessGroup({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"listAccessGroupProjects",
		"List projects of an access group",
		{
			idOrName: listAccessGroupProjectsPathParamsSchema.shape["idOrName"],
			queryParams: listAccessGroupProjectsQueryParamsSchema,
		},
		async ({ idOrName, queryParams }) => {
			try {
				return await listAccessGroupProjects({ pathParams: { idOrName }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"createAccessGroupProject",
		"Allows creation of an access group project",
		{
			accessGroupIdOrName: createAccessGroupProjectPathParamsSchema.shape["accessGroupIdOrName"],
			queryParams: createAccessGroupProjectQueryParamsSchema,
		},
		async ({ accessGroupIdOrName, queryParams }) => {
			try {
				return await createAccessGroupProject({
					pathParams: { accessGroupIdOrName },
					queryParams,
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"readAccessGroupProject",
		"Allows reading an access group project",
		{
			accessGroupIdOrName: readAccessGroupProjectPathParamsSchema.shape["accessGroupIdOrName"],
			projectId: readAccessGroupProjectPathParamsSchema.shape["projectId"],
			queryParams: readAccessGroupProjectQueryParamsSchema,
		},
		async ({ accessGroupIdOrName, projectId, queryParams }) => {
			try {
				return await readAccessGroupProject({
					pathParams: { accessGroupIdOrName, projectId },
					queryParams,
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"updateAccessGroupProject",
		"Allows update of an access group project",
		{
			accessGroupIdOrName: updateAccessGroupProjectPathParamsSchema.shape["accessGroupIdOrName"],
			projectId: updateAccessGroupProjectPathParamsSchema.shape["projectId"],
			queryParams: updateAccessGroupProjectQueryParamsSchema,
		},
		async ({ accessGroupIdOrName, projectId, queryParams }) => {
			try {
				return await updateAccessGroupProject({
					pathParams: { accessGroupIdOrName, projectId },
					queryParams,
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"deleteAccessGroupProject",
		"Allows deletion of an access group project",
		{
			accessGroupIdOrName: deleteAccessGroupProjectPathParamsSchema.shape["accessGroupIdOrName"],
			projectId: deleteAccessGroupProjectPathParamsSchema.shape["projectId"],
			queryParams: deleteAccessGroupProjectQueryParamsSchema,
		},
		async ({ accessGroupIdOrName, projectId, queryParams }) => {
			try {
				return await deleteAccessGroupProject({
					pathParams: { accessGroupIdOrName, projectId },
					queryParams,
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"recordEvents",
		"Records an artifacts cache usage event. The body of this request is an array of cache usage events. The supported event types are `HIT` and `MISS`. The source is either `LOCAL` the cache event was on the users filesystem cache or `REMOTE` if the cache event is for a remote cache. When the event is a `HIT` the request also accepts a number `duration` which is the time taken to generate the artifact in the cache.",
		{ queryParams: recordEventsQueryParamsSchema, headers: recordEventsHeaderParamsSchema },
		async ({ queryParams, headers }) => {
			try {
				return await recordEvents({ queryParams, headers, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"status",
		"Check the status of Remote Caching for this principal. Returns a JSON-encoded status indicating if Remote Caching is enabled, disabled, or disabled due to usage limits.",
		{ queryParams: statusQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await status({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"uploadArtifact",
		"Uploads a cache artifact identified by the `hash` specified on the path. The cache artifact can then be downloaded with the provided `hash`.",
		{
			hash: uploadArtifactPathParamsSchema.shape["hash"],
			headers: uploadArtifactHeaderParamsSchema,
			queryParams: uploadArtifactQueryParamsSchema,
		},
		async ({ hash, headers, queryParams }) => {
			try {
				return await uploadArtifact({ pathParams: { hash }, headers, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"downloadArtifact",
		"Downloads a cache artifact indentified by its `hash` specified on the request path. The artifact is downloaded as an octet-stream. The client should verify the content-length header and response body.",
		{
			hash: downloadArtifactPathParamsSchema.shape["hash"],
			queryParams: downloadArtifactQueryParamsSchema,
			headers: downloadArtifactHeaderParamsSchema,
		},
		async ({ hash, queryParams, headers }) => {
			try {
				return await downloadArtifact({ pathParams: { hash }, queryParams, headers, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"artifactQuery",
		"Query information about an array of artifacts.",
		{ queryParams: artifactQueryQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await artifactQuery({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"gETV1BillingCharges",
		"Returns the billing charge data in FOCUS v1.3 JSONL format for a specified Vercel `teamId`, in a date range `from` and `to` (inclusive).",
		async () => {
			try {
				return await gETV1BillingCharges({ config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"gETV1BillingContractCommitments",
		"Returns commitment allocations per contract period in FOCUS v1.3 JSONL format for a specified Vercel `teamId`. Returns `null` for non-enterprise teams.",
		async () => {
			try {
				return await gETV1BillingContractCommitments({ config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"stageRedirects",
		"Stages new redirects for a project and returns the new version.",
		{ queryParams: stageRedirectsQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await stageRedirects({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getRedirects",
		"Get the version history for a project's bulk redirects",
		{ queryParams: getRedirectsQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await getRedirects({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"deleteRedirects",
		"Deletes the provided redirects from the latest version of the projects' bulk redirects. Stages a new change with the new redirects and returns the alias for the new version in the response.",
		{ queryParams: deleteRedirectsQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await deleteRedirects({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"editRedirect",
		"Edits a single redirect identified by its source path. Stages a new change with the modified redirect and returns the alias for the new version in the response.",
		{ queryParams: editRedirectQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await editRedirect({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"restoreRedirects",
		"Restores the provided redirects in the staging version to the value in the production version. If no production version exists, removes the redirects from staging.",
		{ queryParams: restoreRedirectsQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await restoreRedirects({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getVersions",
		"Get the version history for a project's bulk redirects",
		{ queryParams: getVersionsQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await getVersions({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"updateVersion",
		"Update a version by promoting staging to production or restoring a previous production version",
		{ queryParams: updateVersionQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await updateVersion({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"createCheck",
		"Creates a new check. This endpoint must be called with an OAuth2 or it will produce a 400 error.",
		{
			deploymentId: createCheckPathParamsSchema.shape["deploymentId"],
			queryParams: createCheckQueryParamsSchema,
		},
		async ({ deploymentId, queryParams }) => {
			try {
				return await createCheck({ pathParams: { deploymentId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getAllChecks",
		"List all of the checks created for a deployment.",
		{
			deploymentId: getAllChecksPathParamsSchema.shape["deploymentId"],
			queryParams: getAllChecksQueryParamsSchema,
		},
		async ({ deploymentId, queryParams }) => {
			try {
				return await getAllChecks({ pathParams: { deploymentId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getCheck",
		"Return a detailed response for a single check.",
		{
			deploymentId: getCheckPathParamsSchema.shape["deploymentId"],
			checkId: getCheckPathParamsSchema.shape["checkId"],
			queryParams: getCheckQueryParamsSchema,
		},
		async ({ deploymentId, checkId, queryParams }) => {
			try {
				return await getCheck({ pathParams: { deploymentId, checkId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"updateCheck",
		"Update an existing check. This endpoint must be called with an OAuth2 or it will produce a 400 error.",
		{
			deploymentId: updateCheckPathParamsSchema.shape["deploymentId"],
			checkId: updateCheckPathParamsSchema.shape["checkId"],
			queryParams: updateCheckQueryParamsSchema,
		},
		async ({ deploymentId, checkId, queryParams }) => {
			try {
				return await updateCheck({ pathParams: { deploymentId, checkId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"rerequestCheck",
		"Rerequest a selected check that has failed.",
		{
			deploymentId: rerequestCheckPathParamsSchema.shape["deploymentId"],
			checkId: rerequestCheckPathParamsSchema.shape["checkId"],
			queryParams: rerequestCheckQueryParamsSchema,
		},
		async ({ deploymentId, checkId, queryParams }) => {
			try {
				return await rerequestCheck({ pathParams: { deploymentId, checkId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"listNetworks",
		"Allows to list Secure Compute networks.",
		{ queryParams: listNetworksQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await listNetworks({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"createNetwork",
		"Allows to create a Secure Compute network.",
		{ queryParams: createNetworkQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await createNetwork({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"deleteNetwork",
		"Allows to delete a Secure Compute network.",
		{
			networkId: deleteNetworkPathParamsSchema.shape["networkId"],
			queryParams: deleteNetworkQueryParamsSchema,
		},
		async ({ networkId, queryParams }) => {
			try {
				return await deleteNetwork({ pathParams: { networkId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"updateNetwork",
		"Allows to update a Secure Compute network.",
		{
			networkId: updateNetworkPathParamsSchema.shape["networkId"],
			queryParams: updateNetworkQueryParamsSchema,
		},
		async ({ networkId, queryParams }) => {
			try {
				return await updateNetwork({ pathParams: { networkId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"readNetwork",
		"Allows to read a Secure Compute network.",
		{
			networkId: readNetworkPathParamsSchema.shape["networkId"],
			queryParams: readNetworkQueryParamsSchema,
		},
		async ({ networkId, queryParams }) => {
			try {
				return await readNetwork({ pathParams: { networkId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getDeploymentEvents",
		"Get the build logs of a deployment by deployment ID and build ID. It can work as an infinite stream of logs or as a JSON endpoint depending on the input parameters.",
		{
			idOrUrl: getDeploymentEventsPathParamsSchema.shape["idOrUrl"],
			queryParams: getDeploymentEventsQueryParamsSchema,
		},
		async ({ idOrUrl, queryParams }) => {
			try {
				return await getDeploymentEvents({ pathParams: { idOrUrl }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"updateIntegrationDeploymentAction",
		"Updates the deployment integration action for the specified integration installation",
		{
			deploymentId: updateIntegrationDeploymentActionPathParamsSchema.shape["deploymentId"],
			integrationConfigurationId:
				updateIntegrationDeploymentActionPathParamsSchema.shape["integrationConfigurationId"],
			resourceId: updateIntegrationDeploymentActionPathParamsSchema.shape["resourceId"],
			action: updateIntegrationDeploymentActionPathParamsSchema.shape["action"],
		},
		async ({ deploymentId, integrationConfigurationId, resourceId, action }) => {
			try {
				return await updateIntegrationDeploymentAction({
					pathParams: { deploymentId, integrationConfigurationId, resourceId, action },
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getDeployment",
		"Retrieves information for a deployment either by supplying its ID (`id` property) or Hostname (`url` property). Additional details will be included when the authenticated user or team is an owner of the deployment.",
		{
			idOrUrl: getDeploymentPathParamsSchema.shape["idOrUrl"],
			queryParams: getDeploymentQueryParamsSchema,
		},
		async ({ idOrUrl, queryParams }) => {
			try {
				return await getDeployment({ pathParams: { idOrUrl }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"createDeployment",
		"Create a new deployment with all the required and intended data. If the deployment is not a git deployment, all files must be provided with the request, either referenced or inlined. Additionally, a deployment id can be specified to redeploy a previous deployment.",
		{ queryParams: createDeploymentQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await createDeployment({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"cancelDeployment",
		"This endpoint allows you to cancel a deployment which is currently building, by supplying its `id` in the URL.",
		{
			id: cancelDeploymentPathParamsSchema.shape["id"],
			queryParams: cancelDeploymentQueryParamsSchema,
		},
		async ({ id, queryParams }) => {
			try {
				return await cancelDeployment({ pathParams: { id }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getRecords",
		"Retrieves a list of DNS records created for a domain name. By default it returns 20 records if no limit is provided. The rest can be retrieved using the pagination options.",
		{
			domain: getRecordsPathParamsSchema.shape["domain"],
			queryParams: getRecordsQueryParamsSchema,
		},
		async ({ domain, queryParams }) => {
			try {
				return await getRecords({ pathParams: { domain }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"createRecord",
		"Creates a DNS record for a domain.",
		{
			domain: createRecordPathParamsSchema.shape["domain"],
			queryParams: createRecordQueryParamsSchema,
		},
		async ({ domain, queryParams }) => {
			try {
				return await createRecord({ pathParams: { domain }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"updateRecord",
		"Updates an existing DNS record for a domain name.",
		{
			recordId: updateRecordPathParamsSchema.shape["recordId"],
			queryParams: updateRecordQueryParamsSchema,
		},
		async ({ recordId, queryParams }) => {
			try {
				return await updateRecord({ pathParams: { recordId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"removeRecord",
		"Removes an existing DNS record from a domain name.",
		{
			domain: removeRecordPathParamsSchema.shape["domain"],
			recordId: removeRecordPathParamsSchema.shape["recordId"],
			queryParams: removeRecordQueryParamsSchema,
		},
		async ({ domain, recordId, queryParams }) => {
			try {
				return await removeRecord({ pathParams: { domain, recordId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getSupportedTlds",
		"Get a list of TLDs supported by Vercel",
		{ queryParams: getSupportedTldsQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await getSupportedTlds({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getTldPrice",
		"Get price data for a specific TLD. This only reflects base prices for the given TLD. Premium domains may have different prices. Use the [Get price data for a domain](https://vercel.com/docs/rest-api/reference/endpoints/domains-registrar/get-price-data-for-a-domain) endpoint to get the price data for a specific domain.",
		{ tld: getTldPricePathParamsSchema.shape["tld"], queryParams: getTldPriceQueryParamsSchema },
		async ({ tld, queryParams }) => {
			try {
				return await getTldPrice({ pathParams: { tld }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getDomainAvailability",
		"Get availability for a specific domain. If the domain is available, it can be purchased using the [Buy a domain](https://vercel.com/docs/rest-api/reference/endpoints/domains-registrar/buy-a-domain) endpoint or the [Buy multiple domains](https://vercel.com/docs/rest-api/reference/endpoints/domains-registrar/buy-multiple-domains) endpoint.",
		{
			domain: getDomainAvailabilityPathParamsSchema.shape["domain"],
			queryParams: getDomainAvailabilityQueryParamsSchema,
		},
		async ({ domain, queryParams }) => {
			try {
				return await getDomainAvailability({ pathParams: { domain }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getDomainPrice",
		"Get price data for a specific domain",
		{
			domain: getDomainPricePathParamsSchema.shape["domain"],
			queryParams: getDomainPriceQueryParamsSchema,
		},
		async ({ domain, queryParams }) => {
			try {
				return await getDomainPrice({ pathParams: { domain }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getBulkAvailability",
		"Get availability for multiple domains. If the domains are available, they can be purchased using the [Buy a domain](https://vercel.com/docs/rest-api/reference/endpoints/domains-registrar/buy-a-domain) endpoint or the [Buy multiple domains](https://vercel.com/docs/rest-api/reference/endpoints/domains-registrar/buy-multiple-domains) endpoint.",
		{ queryParams: getBulkAvailabilityQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await getBulkAvailability({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getDomainAuthCode",
		"Get the auth code for a domain. This is required to transfer a domain from Vercel to another registrar.",
		{
			domain: getDomainAuthCodePathParamsSchema.shape["domain"],
			queryParams: getDomainAuthCodeQueryParamsSchema,
		},
		async ({ domain, queryParams }) => {
			try {
				return await getDomainAuthCode({ pathParams: { domain }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"buySingleDomain",
		"Buy a domain",
		{
			domain: buySingleDomainPathParamsSchema.shape["domain"],
			queryParams: buySingleDomainQueryParamsSchema,
		},
		async ({ domain, queryParams }) => {
			try {
				return await buySingleDomain({ pathParams: { domain }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"buyDomains",
		"Buy multiple domains at once",
		{ queryParams: buyDomainsQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await buyDomains({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"transferInDomain",
		"Transfer a domain in from another registrar",
		{
			domain: transferInDomainPathParamsSchema.shape["domain"],
			queryParams: transferInDomainQueryParamsSchema,
		},
		async ({ domain, queryParams }) => {
			try {
				return await transferInDomain({ pathParams: { domain }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getDomainTransferIn",
		"Get the transfer status for a domain",
		{
			domain: getDomainTransferInPathParamsSchema.shape["domain"],
			queryParams: getDomainTransferInQueryParamsSchema,
		},
		async ({ domain, queryParams }) => {
			try {
				return await getDomainTransferIn({ pathParams: { domain }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"renewDomain",
		"Renew a domain",
		{
			domain: renewDomainPathParamsSchema.shape["domain"],
			queryParams: renewDomainQueryParamsSchema,
		},
		async ({ domain, queryParams }) => {
			try {
				return await renewDomain({ pathParams: { domain }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"updateDomainAutoRenew",
		"Update the auto-renew setting for a domain",
		{
			domain: updateDomainAutoRenewPathParamsSchema.shape["domain"],
			queryParams: updateDomainAutoRenewQueryParamsSchema,
		},
		async ({ domain, queryParams }) => {
			try {
				return await updateDomainAutoRenew({ pathParams: { domain }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"updateDomainNameservers",
		"Update the nameservers for a domain. Pass an empty array to use Vercel's default nameservers.",
		{
			domain: updateDomainNameserversPathParamsSchema.shape["domain"],
			queryParams: updateDomainNameserversQueryParamsSchema,
		},
		async ({ domain, queryParams }) => {
			try {
				return await updateDomainNameservers({ pathParams: { domain }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getContactInfoSchema",
		"Some TLDs require additional contact information. Use this endpoint to get the schema for the tld-specific contact information for a domain.",
		{
			domain: getContactInfoSchemaPathParamsSchema.shape["domain"],
			queryParams: getContactInfoSchemaQueryParamsSchema,
		},
		async ({ domain, queryParams }) => {
			try {
				return await getContactInfoSchema({ pathParams: { domain }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getOrder",
		"Get information about a domain order by its ID",
		{ orderId: getOrderPathParamsSchema.shape["orderId"], queryParams: getOrderQueryParamsSchema },
		async ({ orderId, queryParams }) => {
			try {
				return await getOrder({ pathParams: { orderId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getDomainConfig",
		"Get a Domain's configuration.",
		{
			domain: getDomainConfigPathParamsSchema.shape["domain"],
			queryParams: getDomainConfigQueryParamsSchema,
		},
		async ({ domain, queryParams }) => {
			try {
				return await getDomainConfig({ pathParams: { domain }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getDomain",
		"Get information for a single domain in an account or team.",
		{ domain: getDomainPathParamsSchema.shape["domain"], queryParams: getDomainQueryParamsSchema },
		async ({ domain, queryParams }) => {
			try {
				return await getDomain({ pathParams: { domain }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getDomains",
		"Retrieves a list of domains registered for the authenticated user or team. By default it returns the last 20 domains if no limit is provided.",
		{ queryParams: getDomainsQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await getDomains({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"createOrTransferDomain",
		"This endpoint is used for adding a new apex domain name with Vercel for the authenticating user. Note: This endpoint is no longer used for initiating domain transfers from external registrars to Vercel. For this, please use the endpoint [Transfer-in a domain](https://vercel.com/docs/rest-api/reference/endpoints/domains-registrar/transfer-in-a-domain).",
		{ queryParams: createOrTransferDomainQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await createOrTransferDomain({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"patchDomain",
		"Update or move apex domain. Note: This endpoint is no longer used for updating auto-renew or nameservers. For this, please use the endpoints [Update auto-renew for a domain](https://vercel.com/docs/rest-api/reference/endpoints/domains-registrar/update-auto-renew-for-a-domain) and [Update nameservers for a domain](https://vercel.com/docs/rest-api/reference/endpoints/domains-registrar/update-nameservers-for-a-domain).",
		{
			domain: patchDomainPathParamsSchema.shape["domain"],
			queryParams: patchDomainQueryParamsSchema,
		},
		async ({ domain, queryParams }) => {
			try {
				return await patchDomain({ pathParams: { domain }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"deleteDomain",
		"Delete a previously registered domain name from Vercel. Deleting a domain will automatically remove any associated aliases.",
		{
			domain: deleteDomainPathParamsSchema.shape["domain"],
			queryParams: deleteDomainQueryParamsSchema,
		},
		async ({ domain, queryParams }) => {
			try {
				return await deleteDomain({ pathParams: { domain }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getConfigurableLogDrain",
		"Retrieves a Configurable Log Drain. This endpoint must be called with a team AccessToken (integration OAuth2 clients are not allowed). Only log drains owned by the authenticated team can be accessed.",
		{
			id: getConfigurableLogDrainPathParamsSchema.shape["id"],
			queryParams: getConfigurableLogDrainQueryParamsSchema,
		},
		async ({ id, queryParams }) => {
			try {
				return await getConfigurableLogDrain({ pathParams: { id }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"deleteConfigurableLogDrain",
		"Deletes a Configurable Log Drain. This endpoint must be called with a team AccessToken (integration OAuth2 clients are not allowed). Only log drains owned by the authenticated team can be deleted.",
		{
			id: deleteConfigurableLogDrainPathParamsSchema.shape["id"],
			queryParams: deleteConfigurableLogDrainQueryParamsSchema,
		},
		async ({ id, queryParams }) => {
			try {
				return await deleteConfigurableLogDrain({ pathParams: { id }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getAllLogDrains",
		"Retrieves a list of all the Log Drains owned by the account. This endpoint must be called with an account AccessToken (integration OAuth2 clients are not allowed). Only log drains owned by the authenticated account can be accessed.",
		{ queryParams: getAllLogDrainsQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await getAllLogDrains({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"createConfigurableLogDrain",
		"Creates a configurable log drain. This endpoint must be called with a team AccessToken (integration OAuth2 clients are not allowed)",
		{ queryParams: createConfigurableLogDrainQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await createConfigurableLogDrain({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"createDrain",
		"Create a new Drain with the provided configuration.",
		{ queryParams: createDrainQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await createDrain({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getDrains",
		"Allows to retrieve the list of Drains of the authenticated team.",
		{ queryParams: getDrainsQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await getDrains({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"deleteDrain",
		"Delete a specific Drain by passing the drain id in the URL.",
		{ id: deleteDrainPathParamsSchema.shape["id"], queryParams: deleteDrainQueryParamsSchema },
		async ({ id, queryParams }) => {
			try {
				return await deleteDrain({ pathParams: { id }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getDrain",
		"Get the information for a specific Drain by passing the drain id in the URL.",
		{ id: getDrainPathParamsSchema.shape["id"], queryParams: getDrainQueryParamsSchema },
		async ({ id, queryParams }) => {
			try {
				return await getDrain({ pathParams: { id }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"updateDrain",
		"Update the configuration of an existing drain.",
		{ id: updateDrainPathParamsSchema.shape["id"], queryParams: updateDrainQueryParamsSchema },
		async ({ id, queryParams }) => {
			try {
				return await updateDrain({ pathParams: { id }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"testDrain",
		"Validate the delivery configuration of a Drain using sample events.",
		{ queryParams: testDrainQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await testDrain({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"invalidateByTags",
		"Marks a cache tag as stale, causing cache entries associated with that tag to be revalidated in the background on the next request.",
		{ queryParams: invalidateByTagsQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await invalidateByTags({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"dangerouslyDeleteByTags",
		"Marks a cache tag as deleted, causing cache entries associated with that tag to be revalidated in the foreground on the next request. Use this method with caution because one tag can be associated with many paths and deleting the cache can cause many concurrent requests to the origin leading to cache stampede problem. This method is for advanced use cases and is not recommended; prefer using `invalidateByTag` instead.",
		{ queryParams: dangerouslyDeleteByTagsQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await dangerouslyDeleteByTags({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"invalidateBySrcImages",
		"Marks a source image as stale, causing its corresponding transformed images to be revalidated in the background on the next request.",
		{ queryParams: invalidateBySrcImagesQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await invalidateBySrcImages({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"dangerouslyDeleteBySrcImages",
		"Marks a source image as deleted, causing cache entries associated with that source image to be revalidated in the foreground on the next request. Use this method with caution because one source image can be associated with many paths and deleting the cache can cause many concurrent requests to the origin leading to cache stampede problem. This method is for advanced use cases and is not recommended; prefer using `invalidateBySrcImage` instead.",
		{ queryParams: dangerouslyDeleteBySrcImagesQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await dangerouslyDeleteBySrcImages({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getEdgeConfigs",
		"Returns all Edge Configs.",
		{ queryParams: getEdgeConfigsQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await getEdgeConfigs({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"createEdgeConfig",
		"Creates an Edge Config.",
		{ queryParams: createEdgeConfigQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await createEdgeConfig({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getEdgeConfig",
		"Returns an Edge Config.",
		{
			edgeConfigId: getEdgeConfigPathParamsSchema.shape["edgeConfigId"],
			queryParams: getEdgeConfigQueryParamsSchema,
		},
		async ({ edgeConfigId, queryParams }) => {
			try {
				return await getEdgeConfig({ pathParams: { edgeConfigId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"updateEdgeConfig",
		"Updates an Edge Config.",
		{
			edgeConfigId: updateEdgeConfigPathParamsSchema.shape["edgeConfigId"],
			queryParams: updateEdgeConfigQueryParamsSchema,
		},
		async ({ edgeConfigId, queryParams }) => {
			try {
				return await updateEdgeConfig({ pathParams: { edgeConfigId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"deleteEdgeConfig",
		"Delete an Edge Config by id.",
		{
			edgeConfigId: deleteEdgeConfigPathParamsSchema.shape["edgeConfigId"],
			queryParams: deleteEdgeConfigQueryParamsSchema,
		},
		async ({ edgeConfigId, queryParams }) => {
			try {
				return await deleteEdgeConfig({ pathParams: { edgeConfigId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getEdgeConfigItems",
		"Returns all items of an Edge Config.",
		{
			edgeConfigId: getEdgeConfigItemsPathParamsSchema.shape["edgeConfigId"],
			queryParams: getEdgeConfigItemsQueryParamsSchema,
		},
		async ({ edgeConfigId, queryParams }) => {
			try {
				return await getEdgeConfigItems({ pathParams: { edgeConfigId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"patchEdgeConfigItems",
		"Update multiple Edge Config Items in batch.",
		{
			edgeConfigId: patchEdgeConfigItemsPathParamsSchema.shape["edgeConfigId"],
			queryParams: patchEdgeConfigItemsQueryParamsSchema,
		},
		async ({ edgeConfigId, queryParams }) => {
			try {
				return await patchEdgeConfigItems({ pathParams: { edgeConfigId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getEdgeConfigSchema",
		"Returns the schema of an Edge Config.",
		{
			edgeConfigId: getEdgeConfigSchemaPathParamsSchema.shape["edgeConfigId"],
			queryParams: getEdgeConfigSchemaQueryParamsSchema,
		},
		async ({ edgeConfigId, queryParams }) => {
			try {
				return await getEdgeConfigSchema({ pathParams: { edgeConfigId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"patchEdgeConfigSchema",
		"Update an Edge Config's schema.",
		{
			edgeConfigId: patchEdgeConfigSchemaPathParamsSchema.shape["edgeConfigId"],
			queryParams: patchEdgeConfigSchemaQueryParamsSchema,
		},
		async ({ edgeConfigId, queryParams }) => {
			try {
				return await patchEdgeConfigSchema({ pathParams: { edgeConfigId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"deleteEdgeConfigSchema",
		"Deletes the schema of existing Edge Config.",
		{
			edgeConfigId: deleteEdgeConfigSchemaPathParamsSchema.shape["edgeConfigId"],
			queryParams: deleteEdgeConfigSchemaQueryParamsSchema,
		},
		async ({ edgeConfigId, queryParams }) => {
			try {
				return await deleteEdgeConfigSchema({ pathParams: { edgeConfigId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getEdgeConfigItem",
		"Returns a specific Edge Config Item.",
		{
			edgeConfigId: getEdgeConfigItemPathParamsSchema.shape["edgeConfigId"],
			edgeConfigItemKey: getEdgeConfigItemPathParamsSchema.shape["edgeConfigItemKey"],
			queryParams: getEdgeConfigItemQueryParamsSchema,
		},
		async ({ edgeConfigId, edgeConfigItemKey, queryParams }) => {
			try {
				return await getEdgeConfigItem({
					pathParams: { edgeConfigId, edgeConfigItemKey },
					queryParams,
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getEdgeConfigTokens",
		"Returns all tokens of an Edge Config.",
		{
			edgeConfigId: getEdgeConfigTokensPathParamsSchema.shape["edgeConfigId"],
			queryParams: getEdgeConfigTokensQueryParamsSchema,
		},
		async ({ edgeConfigId, queryParams }) => {
			try {
				return await getEdgeConfigTokens({ pathParams: { edgeConfigId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"deleteEdgeConfigTokens",
		"Deletes one or more tokens of an existing Edge Config.",
		{
			edgeConfigId: deleteEdgeConfigTokensPathParamsSchema.shape["edgeConfigId"],
			queryParams: deleteEdgeConfigTokensQueryParamsSchema,
		},
		async ({ edgeConfigId, queryParams }) => {
			try {
				return await deleteEdgeConfigTokens({ pathParams: { edgeConfigId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getEdgeConfigToken",
		"Return meta data about an Edge Config token.",
		{
			edgeConfigId: getEdgeConfigTokenPathParamsSchema.shape["edgeConfigId"],
			token: getEdgeConfigTokenPathParamsSchema.shape["token"],
			queryParams: getEdgeConfigTokenQueryParamsSchema,
		},
		async ({ edgeConfigId, token, queryParams }) => {
			try {
				return await getEdgeConfigToken({
					pathParams: { edgeConfigId, token },
					queryParams,
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"createEdgeConfigToken",
		"Adds a token to an existing Edge Config.",
		{
			edgeConfigId: createEdgeConfigTokenPathParamsSchema.shape["edgeConfigId"],
			queryParams: createEdgeConfigTokenQueryParamsSchema,
		},
		async ({ edgeConfigId, queryParams }) => {
			try {
				return await createEdgeConfigToken({ pathParams: { edgeConfigId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getEdgeConfigBackup",
		"Retrieves a specific version of an Edge Config from backup storage.",
		{
			edgeConfigId: getEdgeConfigBackupPathParamsSchema.shape["edgeConfigId"],
			edgeConfigBackupVersionId:
				getEdgeConfigBackupPathParamsSchema.shape["edgeConfigBackupVersionId"],
			queryParams: getEdgeConfigBackupQueryParamsSchema,
		},
		async ({ edgeConfigId, edgeConfigBackupVersionId, queryParams }) => {
			try {
				return await getEdgeConfigBackup({
					pathParams: { edgeConfigId, edgeConfigBackupVersionId },
					queryParams,
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getEdgeConfigBackups",
		"Returns backups of an Edge Config.",
		{
			edgeConfigId: getEdgeConfigBackupsPathParamsSchema.shape["edgeConfigId"],
			queryParams: getEdgeConfigBackupsQueryParamsSchema,
		},
		async ({ edgeConfigId, queryParams }) => {
			try {
				return await getEdgeConfigBackups({ pathParams: { edgeConfigId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"createSharedEnvVariable",
		"Creates shared environment variable(s) for a team.",
		{ queryParams: createSharedEnvVariableQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await createSharedEnvVariable({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"listSharedEnvVariable",
		"Lists all Shared Environment Variables for a team, taking into account optional filters.",
		{ queryParams: listSharedEnvVariableQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await listSharedEnvVariable({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"updateSharedEnvVariable",
		"Updates a given Shared Environment Variable for a Team.",
		{ queryParams: updateSharedEnvVariableQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await updateSharedEnvVariable({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"deleteSharedEnvVariable",
		"Deletes one or many Shared Environment Variables for a given team.",
		{ queryParams: deleteSharedEnvVariableQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await deleteSharedEnvVariable({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getSharedEnvVar",
		"Retrieve the decrypted value of a Shared Environment Variable by id.",
		{
			id: getSharedEnvVarPathParamsSchema.shape["id"],
			queryParams: getSharedEnvVarQueryParamsSchema,
		},
		async ({ id, queryParams }) => {
			try {
				return await getSharedEnvVar({ pathParams: { id }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"unlinkSharedEnvVariable",
		"Disconnects a shared environment variable for a given project",
		{
			id: unlinkSharedEnvVariablePathParamsSchema.shape["id"],
			projectId: unlinkSharedEnvVariablePathParamsSchema.shape["projectId"],
			queryParams: unlinkSharedEnvVariableQueryParamsSchema,
		},
		async ({ id, projectId, queryParams }) => {
			try {
				return await unlinkSharedEnvVariable({
					pathParams: { id, projectId },
					queryParams,
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"listUserEvents",
		'Retrieves a list of "events" generated by the User on Vercel. Events are generated when the User performs a particular action, such as logging in, creating a deployment, and joining a Team (just to name a few). When the `teamId` parameter is supplied, then the events that are returned will be in relation to the Team that was specified.',
		{ queryParams: listUserEventsQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await listUserEvents({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"gitNamespaces",
		"Lists git namespaces for a supported provider. Supported providers are `github`, `gitlab` and `bitbucket`. If the provider is not provided, it will try to obtain it from the user that authenticated the request.",
		{ queryParams: gitNamespacesQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await gitNamespaces({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"searchRepo",
		"Lists git repositories linked to a namespace `id` for a supported provider. A specific namespace `id` can be obtained via the `git-namespaces`  endpoint. Supported providers are `github`, `gitlab` and `bitbucket`. If the provider or namespace is not provided, it will try to obtain it from the user that authenticated the request.",
		{ queryParams: searchRepoQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await searchRepo({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getBillingPlans",
		"Get a list of billing plans for an integration and product.",
		{
			integrationIdOrSlug: getBillingPlansPathParamsSchema.shape["integrationIdOrSlug"],
			productIdOrSlug: getBillingPlansPathParamsSchema.shape["productIdOrSlug"],
			queryParams: getBillingPlansQueryParamsSchema,
		},
		async ({ integrationIdOrSlug, productIdOrSlug, queryParams }) => {
			try {
				return await getBillingPlans({
					pathParams: { integrationIdOrSlug, productIdOrSlug },
					queryParams,
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"connectIntegrationResourceToProject",
		"Connects an integration resource to a Vercel project. This endpoint establishes a connection between a provisioned integration resource (from storage APIs like `POST /v1/storage/stores/integration/direct`) and a specific Vercel project.",
		{
			integrationConfigurationId:
				connectIntegrationResourceToProjectPathParamsSchema.shape["integrationConfigurationId"],
			resourceId: connectIntegrationResourceToProjectPathParamsSchema.shape["resourceId"],
			queryParams: connectIntegrationResourceToProjectQueryParamsSchema,
		},
		async ({ integrationConfigurationId, resourceId, queryParams }) => {
			try {
				return await connectIntegrationResourceToProject({
					pathParams: { integrationConfigurationId, resourceId },
					queryParams,
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"updateInstallation",
		"This endpoint updates an integration installation.",
		{
			integrationConfigurationId:
				updateInstallationPathParamsSchema.shape["integrationConfigurationId"],
		},
		async ({ integrationConfigurationId }) => {
			try {
				return await updateInstallation({ pathParams: { integrationConfigurationId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getAccountInfo",
		"Fetches the best account or users contact info",
		{
			integrationConfigurationId:
				getAccountInfoPathParamsSchema.shape["integrationConfigurationId"],
		},
		async ({ integrationConfigurationId }) => {
			try {
				return await getAccountInfo({ pathParams: { integrationConfigurationId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getMember",
		'Returns the member role and other information for a given member ID ("user_id" claim in the SSO OIDC token).',
		{
			integrationConfigurationId: getMemberPathParamsSchema.shape["integrationConfigurationId"],
			memberId: getMemberPathParamsSchema.shape["memberId"],
		},
		async ({ integrationConfigurationId, memberId }) => {
			try {
				return await getMember({ pathParams: { integrationConfigurationId, memberId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"createEvent",
		"Partner notifies Vercel of any changes made to an Installation or a Resource. Vercel is expected to use `list-resources` and other read APIs to get the new state.<br/> <br/> `resource.updated` event should be dispatched when any state of a resource linked to Vercel is modified by the partner.<br/> `installation.updated` event should be dispatched when an installation's billing plan is changed via the provider instead of Vercel.<br/> <br/> Resource update use cases: <br/> <br/> - The user renames a database in the partners application. The partner should dispatch a `resource.updated` event to notify Vercel to update the resource in Vercels datastores.<br/> - A resource has been suspended due to a lack of use. The partner should dispatch a `resource.updated` event to notify Vercel to update the resource's status in Vercel's datastores.<br/>",
		{ integrationConfigurationId: createEventPathParamsSchema.shape["integrationConfigurationId"] },
		async ({ integrationConfigurationId }) => {
			try {
				return await createEvent({ pathParams: { integrationConfigurationId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getIntegrationResources",
		"Get all resources for a given installation ID.",
		{
			integrationConfigurationId:
				getIntegrationResourcesPathParamsSchema.shape["integrationConfigurationId"],
		},
		async ({ integrationConfigurationId }) => {
			try {
				return await getIntegrationResources({
					pathParams: { integrationConfigurationId },
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getIntegrationResource",
		"Get a resource by its partner ID.",
		{
			integrationConfigurationId:
				getIntegrationResourcePathParamsSchema.shape["integrationConfigurationId"],
			resourceId: getIntegrationResourcePathParamsSchema.shape["resourceId"],
		},
		async ({ integrationConfigurationId, resourceId }) => {
			try {
				return await getIntegrationResource({
					pathParams: { integrationConfigurationId, resourceId },
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"deleteIntegrationResource",
		"Delete a resource owned by the selected installation ID.",
		{
			integrationConfigurationId:
				deleteIntegrationResourcePathParamsSchema.shape["integrationConfigurationId"],
			resourceId: deleteIntegrationResourcePathParamsSchema.shape["resourceId"],
		},
		async ({ integrationConfigurationId, resourceId }) => {
			try {
				return await deleteIntegrationResource({
					pathParams: { integrationConfigurationId, resourceId },
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"importResource",
		"This endpoint imports (upserts) a resource to Vercel's installation. This may be needed if resources can be independently created on the partner's side and need to be synchronized to Vercel.",
		{
			integrationConfigurationId:
				importResourcePathParamsSchema.shape["integrationConfigurationId"],
			resourceId: importResourcePathParamsSchema.shape["resourceId"],
		},
		async ({ integrationConfigurationId, resourceId }) => {
			try {
				return await importResource({
					pathParams: { integrationConfigurationId, resourceId },
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"updateResource",
		"This endpoint updates an existing resource in the installation. All parameters are optional, allowing partial updates.",
		{
			integrationConfigurationId:
				updateResourcePathParamsSchema.shape["integrationConfigurationId"],
			resourceId: updateResourcePathParamsSchema.shape["resourceId"],
		},
		async ({ integrationConfigurationId, resourceId }) => {
			try {
				return await updateResource({
					pathParams: { integrationConfigurationId, resourceId },
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"submitBillingData",
		"Sends the billing and usage data. The partner should do this at least once a day and ideally once per hour. <br/> Use the `credentials.access_token` we provided in the [Upsert Installation](#upsert-installation) body to authorize this request.",
		{
			integrationConfigurationId:
				submitBillingDataPathParamsSchema.shape["integrationConfigurationId"],
		},
		async ({ integrationConfigurationId }) => {
			try {
				return await submitBillingData({ pathParams: { integrationConfigurationId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"submitInvoice",
		"This endpoint allows the partner to submit an invoice to Vercel. The invoice is created in Vercel's billing system and sent to the customer. Depending on the type of billing plan, the invoice can be sent at a time of signup, at the start of the billing period, or at the end of the billing period.<br/> <br/> Use the `credentials.access_token` we provided in the [Upsert Installation](#upsert-installation) body to authorize this request. <br/> There are several limitations to the invoice submission:<br/> <br/> 1. A resource can only be billed once per the billing period and the billing plan.<br/> 2. The billing plan used to bill the resource must have been active for this resource during the billing period.<br/> 3. The billing plan used must be a subscription plan.<br/> 4. The interim usage data must be sent hourly for all types of subscriptions. See [Send subscription billing and usage data](#send-subscription-billing-and-usage-data) API on how to send interim billing and usage data.<br/>",
		{
			integrationConfigurationId: submitInvoicePathParamsSchema.shape["integrationConfigurationId"],
		},
		async ({ integrationConfigurationId }) => {
			try {
				return await submitInvoice({ pathParams: { integrationConfigurationId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getInvoice",
		"Get Invoice details and status for a given invoice ID.<br/> <br/> See Billing Events with Webhooks documentation on how to receive invoice events. This endpoint is used to retrieve the invoice details.",
		{
			integrationConfigurationId: getInvoicePathParamsSchema.shape["integrationConfigurationId"],
			invoiceId: getInvoicePathParamsSchema.shape["invoiceId"],
		},
		async ({ integrationConfigurationId, invoiceId }) => {
			try {
				return await getInvoice({ pathParams: { integrationConfigurationId, invoiceId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"updateInvoice",
		"This endpoint allows the partner to request a refund for an invoice to Vercel. The invoice is created using the [Submit Invoice API](#submit-invoice-api).",
		{
			integrationConfigurationId: updateInvoicePathParamsSchema.shape["integrationConfigurationId"],
			invoiceId: updateInvoicePathParamsSchema.shape["invoiceId"],
		},
		async ({ integrationConfigurationId, invoiceId }) => {
			try {
				return await updateInvoice({
					pathParams: { integrationConfigurationId, invoiceId },
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"submitPrepaymentBalances",
		"Sends the prepayment balances. The partner should do this at least once a day and ideally once per hour. <br/> Use the `credentials.access_token` we provided in the [Upsert Installation](#upsert-installation) body to authorize this request.",
		{
			integrationConfigurationId:
				submitPrepaymentBalancesPathParamsSchema.shape["integrationConfigurationId"],
		},
		async ({ integrationConfigurationId }) => {
			try {
				return await submitPrepaymentBalances({
					pathParams: { integrationConfigurationId },
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"updateResourceSecrets",
		"This endpoint is deprecated and replaced with the endpoint [Update Resource Secrets](#update-resource-secrets). <br/> This endpoint updates the secrets of a resource. If a resource has projects connected, the connected secrets are updated with the new secrets. The old secrets may still be used by existing connected projects because they are not automatically redeployed. Redeployment is a manual action and must be completed by the user. All new project connections will use the new secrets.<br/> <br/> Use cases for this endpoint:<br/> <br/> - Resetting the credentials of a database in the partner. If the user requests the credentials to be updated in the partners application, the partner post the new set of secrets to Vercel, the user should redeploy their application and the expire the old credentials.<br/>",
		{
			integrationConfigurationId:
				updateResourceSecretsPathParamsSchema.shape["integrationConfigurationId"],
			integrationProductIdOrSlug:
				updateResourceSecretsPathParamsSchema.shape["integrationProductIdOrSlug"],
			resourceId: updateResourceSecretsPathParamsSchema.shape["resourceId"],
		},
		async ({ integrationConfigurationId, integrationProductIdOrSlug, resourceId }) => {
			try {
				return await updateResourceSecrets({
					pathParams: { integrationConfigurationId, integrationProductIdOrSlug, resourceId },
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"updateResourceSecretsById",
		"This endpoint updates the secrets of a resource. If a resource has projects connected, the connected secrets are updated with the new secrets. The old secrets may still be used by existing connected projects because they are not automatically redeployed. Redeployment is a manual action and must be completed by the user. All new project connections will use the new secrets.<br/> <br/> Use cases for this endpoint:<br/> <br/> - Resetting the credentials of a database in the partner. If the user requests the credentials to be updated in the partners application, the partner post the new set of secrets to Vercel, the user should redeploy their application and the expire the old credentials.<br/>",
		{
			integrationConfigurationId:
				updateResourceSecretsByIdPathParamsSchema.shape["integrationConfigurationId"],
			resourceId: updateResourceSecretsByIdPathParamsSchema.shape["resourceId"],
		},
		async ({ integrationConfigurationId, resourceId }) => {
			try {
				return await updateResourceSecretsById({
					pathParams: { integrationConfigurationId, resourceId },
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getConfigurations",
		"Allows to retrieve all configurations for an authenticated integration. When the `project` view is used, configurations generated for the authorization flow will be filtered out of the results.",
		{ queryParams: getConfigurationsQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await getConfigurations({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getConfiguration",
		"Allows to retrieve a the configuration with the provided id in case it exists. The authenticated user or team must be the owner of the config in order to access it.",
		{
			id: getConfigurationPathParamsSchema.shape["id"],
			queryParams: getConfigurationQueryParamsSchema,
		},
		async ({ id, queryParams }) => {
			try {
				return await getConfiguration({ pathParams: { id }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"deleteConfiguration",
		"Allows to remove the configuration with the `id` provided in the parameters. The configuration and all of its resources will be removed. This includes Webhooks, LogDrains and Project Env variables.",
		{
			id: deleteConfigurationPathParamsSchema.shape["id"],
			queryParams: deleteConfigurationQueryParamsSchema,
		},
		async ({ id, queryParams }) => {
			try {
				return await deleteConfiguration({ pathParams: { id }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getConfigurationProducts",
		"Returns products available for an integration configuration. Each product includes a `metadataSchema` field with the JSON Schema for required and optional metadata fields.",
		{
			id: getConfigurationProductsPathParamsSchema.shape["id"],
			queryParams: getConfigurationProductsQueryParamsSchema,
		},
		async ({ id, queryParams }) => {
			try {
				return await getConfigurationProducts({ pathParams: { id }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"exchangeSsoToken",
		"During the autorization process, Vercel sends the user to the provider [redirectLoginUrl](https://vercel.com/docs/integrations/create-integration/submit-integration#redirect-login-url), that includes the OAuth authorization `code` parameter. The provider then calls the SSO Token Exchange endpoint with the sent code and receives the OIDC token. They log the user in based on this token and redirects the user back to the Vercel account using deep-link parameters included the redirectLoginUrl. Providers should not persist the returned `id_token` in a database since the token will expire. See [**Authentication with SSO**](https://vercel.com/docs/integrations/create-integration/marketplace-api#authentication-with-sso) for more details.",
		async () => {
			try {
				return await exchangeSsoToken({ config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getIntegrationLogDrains",
		"Retrieves a list of all Integration log drains that are defined for the authenticated user or team. When using an OAuth2 token, the list is limited to log drains created by the authenticated integration.",
		{ queryParams: getIntegrationLogDrainsQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await getIntegrationLogDrains({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"createLogDrain",
		"Creates an Integration log drain. This endpoint must be called with an OAuth2 client (integration), since log drains are tied to integrations. If it is called with a different token type it will produce a 400 error.",
		{ queryParams: createLogDrainQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await createLogDrain({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"deleteIntegrationLogDrain",
		"Deletes the Integration log drain with the provided `id`. When using an OAuth2 Token, the log drain can be deleted only if the integration owns it.",
		{
			id: deleteIntegrationLogDrainPathParamsSchema.shape["id"],
			queryParams: deleteIntegrationLogDrainQueryParamsSchema,
		},
		async ({ id, queryParams }) => {
			try {
				return await deleteIntegrationLogDrain({ pathParams: { id }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getRuntimeLogs",
		"Returns a stream of logs for a given deployment.",
		{
			projectId: getRuntimeLogsPathParamsSchema.shape["projectId"],
			deploymentId: getRuntimeLogsPathParamsSchema.shape["deploymentId"],
			queryParams: getRuntimeLogsQueryParamsSchema,
		},
		async ({ projectId, deploymentId, queryParams }) => {
			try {
				return await getRuntimeLogs({
					pathParams: { projectId, deploymentId },
					queryParams,
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"createExperimentationItem",
		"Create one or multiple experimentation items",
		{
			integrationConfigurationId:
				createExperimentationItemPathParamsSchema.shape["integrationConfigurationId"],
			resourceId: createExperimentationItemPathParamsSchema.shape["resourceId"],
		},
		async ({ integrationConfigurationId, resourceId }) => {
			try {
				return await createExperimentationItem({
					pathParams: { integrationConfigurationId, resourceId },
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"updateExperimentationItem",
		"Patch an existing experimentation item",
		{
			integrationConfigurationId:
				updateExperimentationItemPathParamsSchema.shape["integrationConfigurationId"],
			resourceId: updateExperimentationItemPathParamsSchema.shape["resourceId"],
			itemId: updateExperimentationItemPathParamsSchema.shape["itemId"],
		},
		async ({ integrationConfigurationId, resourceId, itemId }) => {
			try {
				return await updateExperimentationItem({
					pathParams: { integrationConfigurationId, resourceId, itemId },
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"deleteExperimentationItem",
		"Delete an existing experimentation item",
		{
			integrationConfigurationId:
				deleteExperimentationItemPathParamsSchema.shape["integrationConfigurationId"],
			resourceId: deleteExperimentationItemPathParamsSchema.shape["resourceId"],
			itemId: deleteExperimentationItemPathParamsSchema.shape["itemId"],
		},
		async ({ integrationConfigurationId, resourceId, itemId }) => {
			try {
				return await deleteExperimentationItem({
					pathParams: { integrationConfigurationId, resourceId, itemId },
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"gETV1InstallationsIntegrationConfigurationIdResourcesResourceIdExperimentationEdgeConfig",
		"When the user enabled Edge Config syncing, then this endpoint can be used by the partner to fetch the contents of the Edge Config.",
		{
			integrationConfigurationId:
				GETV1InstallationsIntegrationConfigurationIdResourcesResourceIdExperimentationEdgeConfigPathParamsSchema
					.shape["integrationConfigurationId"],
			resourceId:
				GETV1InstallationsIntegrationConfigurationIdResourcesResourceIdExperimentationEdgeConfigPathParamsSchema
					.shape["resourceId"],
		},
		async ({ integrationConfigurationId, resourceId }) => {
			try {
				return await gETV1InstallationsIntegrationConfigurationIdResourcesResourceIdExperimentationEdgeConfig(
					{ pathParams: { integrationConfigurationId, resourceId }, config },
				);
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"updateExperimentationEdgeConfig",
		"When the user enabled Edge Config syncing, then this endpoint can be used by the partner to push their configuration data into the relevant Edge Config.",
		{
			integrationConfigurationId:
				updateExperimentationEdgeConfigPathParamsSchema.shape["integrationConfigurationId"],
			resourceId: updateExperimentationEdgeConfigPathParamsSchema.shape["resourceId"],
		},
		async ({ integrationConfigurationId, resourceId }) => {
			try {
				return await updateExperimentationEdgeConfig({
					pathParams: { integrationConfigurationId, resourceId },
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getProjectMembers",
		"Lists all members of a project.",
		{
			idOrName: getProjectMembersPathParamsSchema.shape["idOrName"],
			queryParams: getProjectMembersQueryParamsSchema,
		},
		async ({ idOrName, queryParams }) => {
			try {
				return await getProjectMembers({ pathParams: { idOrName }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"addProjectMember",
		"Adds a new member to the project.",
		{
			idOrName: addProjectMemberPathParamsSchema.shape["idOrName"],
			queryParams: addProjectMemberQueryParamsSchema,
		},
		async ({ idOrName, queryParams }) => {
			try {
				return await addProjectMember({ pathParams: { idOrName }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"removeProjectMember",
		"Remove a member from a specific project",
		{
			idOrName: removeProjectMemberPathParamsSchema.shape["idOrName"],
			uid: removeProjectMemberPathParamsSchema.shape["uid"],
			queryParams: removeProjectMemberQueryParamsSchema,
		},
		async ({ idOrName, uid, queryParams }) => {
			try {
				return await removeProjectMember({ pathParams: { idOrName, uid }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getProjects",
		"Allows to retrieve the list of projects of the authenticated user or team. The list will be paginated and the provided query parameters allow filtering the returned projects.",
		{ queryParams: getProjectsQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await getProjects({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"createProject",
		"Allows to create a new project with the provided configuration. It only requires the project `name` but more configuration can be provided to override the defaults.",
		{ queryParams: createProjectQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await createProject({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getProject",
		"Get the information for a specific project by passing either the project `id` or `name` in the URL.",
		{
			idOrName: getProjectPathParamsSchema.shape["idOrName"],
			queryParams: getProjectQueryParamsSchema,
		},
		async ({ idOrName, queryParams }) => {
			try {
				return await getProject({ pathParams: { idOrName }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"updateProject",
		"Update the fields of a project using either its `name` or `id`.",
		{
			idOrName: updateProjectPathParamsSchema.shape["idOrName"],
			queryParams: updateProjectQueryParamsSchema,
		},
		async ({ idOrName, queryParams }) => {
			try {
				return await updateProject({ pathParams: { idOrName }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"deleteProject",
		"Delete a specific project by passing either the project `id` or `name` in the URL.",
		{
			idOrName: deleteProjectPathParamsSchema.shape["idOrName"],
			queryParams: deleteProjectQueryParamsSchema,
		},
		async ({ idOrName, queryParams }) => {
			try {
				return await deleteProject({ pathParams: { idOrName }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"updateStaticIps",
		"Allows configuring Static IPs for a project",
		{
			idOrName: updateStaticIpsPathParamsSchema.shape["idOrName"],
			queryParams: updateStaticIpsQueryParamsSchema,
		},
		async ({ idOrName, queryParams }) => {
			try {
				return await updateStaticIps({ pathParams: { idOrName }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"createCustomEnvironment",
		"Creates a custom environment for the current project. Cannot be named 'Production' or 'Preview'.",
		{
			idOrName: createCustomEnvironmentPathParamsSchema.shape["idOrName"],
			queryParams: createCustomEnvironmentQueryParamsSchema,
		},
		async ({ idOrName, queryParams }) => {
			try {
				return await createCustomEnvironment({ pathParams: { idOrName }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"listCustomEnvironments",
		"Retrieve custom environments for the project. Must not be named 'Production' or 'Preview'.",
		{
			idOrName: listCustomEnvironmentsPathParamsSchema.shape["idOrName"],
			queryParams: listCustomEnvironmentsQueryParamsSchema,
		},
		async ({ idOrName, queryParams }) => {
			try {
				return await listCustomEnvironments({ pathParams: { idOrName }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getCustomEnvironment",
		"Retrieve a custom environment for the project. Must not be named 'Production' or 'Preview'.",
		{
			idOrName: getCustomEnvironmentPathParamsSchema.shape["idOrName"],
			environmentSlugOrId: getCustomEnvironmentPathParamsSchema.shape["environmentSlugOrId"],
			queryParams: getCustomEnvironmentQueryParamsSchema,
		},
		async ({ idOrName, environmentSlugOrId, queryParams }) => {
			try {
				return await getCustomEnvironment({
					pathParams: { idOrName, environmentSlugOrId },
					queryParams,
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"updateCustomEnvironment",
		"Update a custom environment for the project. Must not be named 'Production' or 'Preview'.",
		{
			idOrName: updateCustomEnvironmentPathParamsSchema.shape["idOrName"],
			environmentSlugOrId: updateCustomEnvironmentPathParamsSchema.shape["environmentSlugOrId"],
			queryParams: updateCustomEnvironmentQueryParamsSchema,
		},
		async ({ idOrName, environmentSlugOrId, queryParams }) => {
			try {
				return await updateCustomEnvironment({
					pathParams: { idOrName, environmentSlugOrId },
					queryParams,
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"removeCustomEnvironment",
		"Remove a custom environment for the project. Must not be named 'Production' or 'Preview'.",
		{
			idOrName: removeCustomEnvironmentPathParamsSchema.shape["idOrName"],
			environmentSlugOrId: removeCustomEnvironmentPathParamsSchema.shape["environmentSlugOrId"],
			queryParams: removeCustomEnvironmentQueryParamsSchema,
		},
		async ({ idOrName, environmentSlugOrId, queryParams }) => {
			try {
				return await removeCustomEnvironment({
					pathParams: { idOrName, environmentSlugOrId },
					queryParams,
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getProjectDomains",
		"Retrieve the domains associated with a given project by passing either the project `id` or `name` in the URL.",
		{
			idOrName: getProjectDomainsPathParamsSchema.shape["idOrName"],
			queryParams: getProjectDomainsQueryParamsSchema,
		},
		async ({ idOrName, queryParams }) => {
			try {
				return await getProjectDomains({ pathParams: { idOrName }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getProjectDomain",
		"Get project domain by project id/name and domain name.",
		{
			idOrName: getProjectDomainPathParamsSchema.shape["idOrName"],
			domain: getProjectDomainPathParamsSchema.shape["domain"],
			queryParams: getProjectDomainQueryParamsSchema,
		},
		async ({ idOrName, domain, queryParams }) => {
			try {
				return await getProjectDomain({ pathParams: { idOrName, domain }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"updateProjectDomain",
		"Update a project domain's configuration, including the name, git branch and redirect of the domain.",
		{
			idOrName: updateProjectDomainPathParamsSchema.shape["idOrName"],
			domain: updateProjectDomainPathParamsSchema.shape["domain"],
			queryParams: updateProjectDomainQueryParamsSchema,
		},
		async ({ idOrName, domain, queryParams }) => {
			try {
				return await updateProjectDomain({ pathParams: { idOrName, domain }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"removeProjectDomain",
		"Remove a domain from a project by passing the domain name and by specifying the project by either passing the project `id` or `name` in the URL.",
		{
			idOrName: removeProjectDomainPathParamsSchema.shape["idOrName"],
			domain: removeProjectDomainPathParamsSchema.shape["domain"],
			queryParams: removeProjectDomainQueryParamsSchema,
		},
		async ({ idOrName, domain, queryParams }) => {
			try {
				return await removeProjectDomain({ pathParams: { idOrName, domain }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"addProjectDomain",
		"Add a domain to the project by passing its domain name and by specifying the project by either passing the project `id` or `name` in the URL. If the domain is not yet verified to be used on this project, the request will return `verified = false`, and the domain will need to be verified according to the `verification` challenge via `POST /projects/:idOrName/domains/:domain/verify`. If the domain already exists on the project, the request will fail with a `400` status code.",
		{
			idOrName: addProjectDomainPathParamsSchema.shape["idOrName"],
			queryParams: addProjectDomainQueryParamsSchema,
		},
		async ({ idOrName, queryParams }) => {
			try {
				return await addProjectDomain({ pathParams: { idOrName }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"moveProjectDomain",
		"Move one project's domain to another project. Also allows the move of all redirects pointed to that domain in the same project.",
		{
			idOrName: moveProjectDomainPathParamsSchema.shape["idOrName"],
			domain: moveProjectDomainPathParamsSchema.shape["domain"],
			queryParams: moveProjectDomainQueryParamsSchema,
		},
		async ({ idOrName, domain, queryParams }) => {
			try {
				return await moveProjectDomain({ pathParams: { idOrName, domain }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"verifyProjectDomain",
		"Attempts to verify a project domain with `verified = false` by checking the correctness of the project domain's `verification` challenge.",
		{
			idOrName: verifyProjectDomainPathParamsSchema.shape["idOrName"],
			domain: verifyProjectDomainPathParamsSchema.shape["domain"],
			queryParams: verifyProjectDomainQueryParamsSchema,
		},
		async ({ idOrName, domain, queryParams }) => {
			try {
				return await verifyProjectDomain({ pathParams: { idOrName, domain }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"filterProjectEnvs",
		"Retrieve the environment variables for a given project by passing either the project `id` or `name` in the URL.",
		{
			idOrName: filterProjectEnvsPathParamsSchema.shape["idOrName"],
			queryParams: filterProjectEnvsQueryParamsSchema,
		},
		async ({ idOrName, queryParams }) => {
			try {
				return await filterProjectEnvs({ pathParams: { idOrName }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"createProjectEnv",
		"Create one or more environment variables for a project by passing its `key`, `value`, `type` and `target` and by specifying the project by either passing the project `id` or `name` in the URL. If you include `upsert=true` as a query parameter, a new environment variable will not be created if it already exists but, the existing variable's value will be updated.",
		{
			idOrName: createProjectEnvPathParamsSchema.shape["idOrName"],
			queryParams: createProjectEnvQueryParamsSchema,
		},
		async ({ idOrName, queryParams }) => {
			try {
				return await createProjectEnv({ pathParams: { idOrName }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getProjectEnv",
		"Retrieve the environment variable for a given project.",
		{
			idOrName: getProjectEnvPathParamsSchema.shape["idOrName"],
			id: getProjectEnvPathParamsSchema.shape["id"],
			queryParams: getProjectEnvQueryParamsSchema,
		},
		async ({ idOrName, id, queryParams }) => {
			try {
				return await getProjectEnv({ pathParams: { idOrName, id }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"removeProjectEnv",
		"Delete a specific environment variable for a given project by passing the environment variable identifier and either passing the project `id` or `name` in the URL.",
		{
			idOrName: removeProjectEnvPathParamsSchema.shape["idOrName"],
			id: removeProjectEnvPathParamsSchema.shape["id"],
			queryParams: removeProjectEnvQueryParamsSchema,
		},
		async ({ idOrName, id, queryParams }) => {
			try {
				return await removeProjectEnv({ pathParams: { idOrName, id }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"editProjectEnv",
		"Edit a specific environment variable for a given project by passing the environment variable identifier and either passing the project `id` or `name` in the URL.",
		{
			idOrName: editProjectEnvPathParamsSchema.shape["idOrName"],
			id: editProjectEnvPathParamsSchema.shape["id"],
			queryParams: editProjectEnvQueryParamsSchema,
		},
		async ({ idOrName, id, queryParams }) => {
			try {
				return await editProjectEnv({ pathParams: { idOrName, id }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"batchRemoveProjectEnv",
		"Delete multiple environment variables for a given project in a single batch operation.",
		{
			idOrName: batchRemoveProjectEnvPathParamsSchema.shape["idOrName"],
			queryParams: batchRemoveProjectEnvQueryParamsSchema,
		},
		async ({ idOrName, queryParams }) => {
			try {
				return await batchRemoveProjectEnv({ pathParams: { idOrName }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getRollingReleaseBillingStatus",
		"Get the Rolling Releases billing status for a project. The team level billing status is used to determine if the project can be configured for rolling releases.",
		{
			idOrName: getRollingReleaseBillingStatusPathParamsSchema.shape["idOrName"],
			queryParams: getRollingReleaseBillingStatusQueryParamsSchema,
		},
		async ({ idOrName, queryParams }) => {
			try {
				return await getRollingReleaseBillingStatus({
					pathParams: { idOrName },
					queryParams,
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getRollingReleaseConfig",
		"Get the Rolling Releases configuration for a project. The project-level config is simply a template that will be used for any future rolling release, and not the configuration for any active rolling release.",
		{
			idOrName: getRollingReleaseConfigPathParamsSchema.shape["idOrName"],
			queryParams: getRollingReleaseConfigQueryParamsSchema,
		},
		async ({ idOrName, queryParams }) => {
			try {
				return await getRollingReleaseConfig({ pathParams: { idOrName }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"deleteRollingReleaseConfig",
		"Disable Rolling Releases for a project means that future deployments will not undergo a rolling release. Changing the config never alters a rollout that's already in-flightit only affects the next production deployment. If you want to also stop the current rollout, call this endpoint to disable the feature, and then call either the /complete or /abort endpoint.",
		{
			idOrName: deleteRollingReleaseConfigPathParamsSchema.shape["idOrName"],
			queryParams: deleteRollingReleaseConfigQueryParamsSchema,
		},
		async ({ idOrName, queryParams }) => {
			try {
				return await deleteRollingReleaseConfig({ pathParams: { idOrName }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"updateRollingReleaseConfig",
		'Update (or disable) Rolling Releases for a project. When disabling with the resolve-on-disable feature flag enabled, any active rolling release document is resolved using the disableRolloutAction parameter: "abort" to roll back (default), or "complete" to promote the canary to production. When enabling or updating config, changes only affect the next production deployment and do not alter a rollout that\'s already in-flight. Note: Enabling Rolling Releases automatically enables skew protection on the project with the default value if it wasn\'t configured already.',
		{
			idOrName: updateRollingReleaseConfigPathParamsSchema.shape["idOrName"],
			queryParams: updateRollingReleaseConfigQueryParamsSchema,
		},
		async ({ idOrName, queryParams }) => {
			try {
				return await updateRollingReleaseConfig({ pathParams: { idOrName }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getRollingRelease",
		"Return the Rolling Release for a project, regardless of whether the rollout is active, aborted, or completed. If the feature is enabled but no deployment has occurred yet, null will be returned.",
		{
			idOrName: getRollingReleasePathParamsSchema.shape["idOrName"],
			queryParams: getRollingReleaseQueryParamsSchema,
		},
		async ({ idOrName, queryParams }) => {
			try {
				return await getRollingRelease({ pathParams: { idOrName }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"approveRollingReleaseStage",
		"Advance a rollout to the next stage. This is only needed when rolling releases is configured to require manual approval.",
		{
			idOrName: approveRollingReleaseStagePathParamsSchema.shape["idOrName"],
			queryParams: approveRollingReleaseStageQueryParamsSchema,
		},
		async ({ idOrName, queryParams }) => {
			try {
				return await approveRollingReleaseStage({ pathParams: { idOrName }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"completeRollingRelease",
		"Force-complete a Rolling Release. The canary deployment will begin serving 100% of the traffic.",
		{
			idOrName: completeRollingReleasePathParamsSchema.shape["idOrName"],
			queryParams: completeRollingReleaseQueryParamsSchema,
		},
		async ({ idOrName, queryParams }) => {
			try {
				return await completeRollingRelease({ pathParams: { idOrName }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"createProjectTransferRequest",
		"Initiates a project transfer request from one team to another. <br/> Returns a `code` that remains valid for 24 hours and can be used to accept the transfer request by another team using the `PUT /projects/transfer-request/:code` endpoint. <br/> Users can also accept the project transfer request using the claim URL: `https://vercel.com/claim-deployment?code=<code>&returnUrl=<returnUrl>`. <br/> The `code` parameter specifies the project transfer request code generated using this endpoint. <br/> The `returnUrl` parameter redirects users to a specific page of the application if the claim URL is invalid or expired.",
		{
			idOrName: createProjectTransferRequestPathParamsSchema.shape["idOrName"],
			queryParams: createProjectTransferRequestQueryParamsSchema,
		},
		async ({ idOrName, queryParams }) => {
			try {
				return await createProjectTransferRequest({
					pathParams: { idOrName },
					queryParams,
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"acceptProjectTransferRequest",
		"Accept a project transfer request initated by another team. <br/> The `code` is generated using the `POST /projects/:idOrName/transfer-request` endpoint.",
		{
			code: acceptProjectTransferRequestPathParamsSchema.shape["code"],
			queryParams: acceptProjectTransferRequestQueryParamsSchema,
		},
		async ({ code, queryParams }) => {
			try {
				return await acceptProjectTransferRequest({ pathParams: { code }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"updateProjectProtectionBypass",
		"Update the deployment protection automation bypass for a project",
		{
			idOrName: updateProjectProtectionBypassPathParamsSchema.shape["idOrName"],
			queryParams: updateProjectProtectionBypassQueryParamsSchema,
		},
		async ({ idOrName, queryParams }) => {
			try {
				return await updateProjectProtectionBypass({
					pathParams: { idOrName },
					queryParams,
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"requestRollback",
		"Allows users to rollback to a deployment.",
		{
			projectId: requestRollbackPathParamsSchema.shape["projectId"],
			deploymentId: requestRollbackPathParamsSchema.shape["deploymentId"],
			queryParams: requestRollbackQueryParamsSchema,
		},
		async ({ projectId, deploymentId, queryParams }) => {
			try {
				return await requestRollback({
					pathParams: { projectId, deploymentId },
					queryParams,
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"pATCHV1ProjectsProjectIdRollbackDeploymentIdUpdateDescription",
		"Updates the reason for a rollback, without changing the rollback status itself.",
		{
			projectId:
				PATCHV1ProjectsProjectIdRollbackDeploymentIdUpdateDescriptionPathParamsSchema.shape[
					"projectId"
				],
			deploymentId:
				PATCHV1ProjectsProjectIdRollbackDeploymentIdUpdateDescriptionPathParamsSchema.shape[
					"deploymentId"
				],
		},
		async ({ projectId, deploymentId }) => {
			try {
				return await pATCHV1ProjectsProjectIdRollbackDeploymentIdUpdateDescription({
					pathParams: { projectId, deploymentId },
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"requestPromote",
		"Allows users to promote a deployment to production. Note: This does NOT rebuild the deployment. If you need that, then call create-deployments endpoint.",
		{
			projectId: requestPromotePathParamsSchema.shape["projectId"],
			deploymentId: requestPromotePathParamsSchema.shape["deploymentId"],
			queryParams: requestPromoteQueryParamsSchema,
		},
		async ({ projectId, deploymentId, queryParams }) => {
			try {
				return await requestPromote({
					pathParams: { projectId, deploymentId },
					queryParams,
					config,
				});
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"listPromoteAliases",
		"Get a list of aliases related to the last promote request with their mapping status",
		{
			projectId: listPromoteAliasesPathParamsSchema.shape["projectId"],
			queryParams: listPromoteAliasesQueryParamsSchema,
		},
		async ({ projectId, queryParams }) => {
			try {
				return await listPromoteAliases({ pathParams: { projectId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"pauseProject",
		"Pause a project by passing its project `id` in the URL. If the project does not exist given the id then the request will fail with 400 status code. If the project disables auto assigning custom production domains and blocks the active Production Deployment then the request will return with 200 status code.",
		{
			projectId: pauseProjectPathParamsSchema.shape["projectId"],
			queryParams: pauseProjectQueryParamsSchema,
		},
		async ({ projectId, queryParams }) => {
			try {
				return await pauseProject({ pathParams: { projectId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"unpauseProject",
		"Unpause a project by passing its project `id` in the URL. If the project does not exist given the id then the request will fail with 400 status code. If the project enables auto assigning custom production domains and unblocks the active Production Deployment then the request will return with 200 status code.",
		{
			projectId: unpauseProjectPathParamsSchema.shape["projectId"],
			queryParams: unpauseProjectQueryParamsSchema,
		},
		async ({ projectId, queryParams }) => {
			try {
				return await unpauseProject({ pathParams: { projectId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"updateAttackChallengeMode",
		"Update the setting for determining if the project has Attack Challenge mode enabled.",
		{ queryParams: updateAttackChallengeModeQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await updateAttackChallengeMode({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"putFirewallConfig",
		"Set the firewall configuration to provided rules and settings. Creates or overwrite the existing firewall configuration.",
		{ queryParams: putFirewallConfigQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await putFirewallConfig({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"updateFirewallConfig",
		"Process updates to modify the existing firewall config for a project",
		{ queryParams: updateFirewallConfigQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await updateFirewallConfig({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getFirewallConfig",
		"Retrieve the specified firewall configuration for a project. The deployed configVersion will be `active`",
		{
			configVersion: getFirewallConfigPathParamsSchema.shape["configVersion"],
			queryParams: getFirewallConfigQueryParamsSchema,
		},
		async ({ configVersion, queryParams }) => {
			try {
				return await getFirewallConfig({ pathParams: { configVersion }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getActiveAttackStatus",
		"Retrieve active attack data within the last N days (default: 1 day)",
		{ queryParams: getActiveAttackStatusQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await getActiveAttackStatus({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getBypassIp",
		"Retrieve the system bypass rules configured for the specified project",
		{ queryParams: getBypassIpQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await getBypassIp({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"addBypassIp",
		"Create new system bypass rules",
		{ queryParams: addBypassIpQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await addBypassIp({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"removeBypassIp",
		"Remove system bypass rules",
		{ queryParams: removeBypassIpQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await removeBypassIp({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"gETV1SecurityFirewallEvents",
		"Retrieve firewall actions for a project",
		{ queryParams: GETV1SecurityFirewallEventsQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await gETV1SecurityFirewallEvents({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"createIntegrationStoreDirect",
		"Creates an integration store with automatic billing plan handling. For free resources, omit `billingPlanId` to auto-discover free plans. For paid resources, provide a `billingPlanId` from the billing plans endpoint.",
		{ queryParams: createIntegrationStoreDirectQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await createIntegrationStoreDirect({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getTeamMembers",
		"Get a paginated list of team members for the provided team.",
		{
			teamId: getTeamMembersPathParamsSchema.shape["teamId"],
			queryParams: getTeamMembersQueryParamsSchema,
		},
		async ({ teamId, queryParams }) => {
			try {
				return await getTeamMembers({ pathParams: { teamId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"inviteUserToTeam",
		"Invite a user to join the team specified in the URL. The authenticated user needs to be an `OWNER` in order to successfully invoke this endpoint. The user to be invited must be specified by email.",
		{ teamId: inviteUserToTeamPathParamsSchema.shape["teamId"] },
		async ({ teamId }) => {
			try {
				return await inviteUserToTeam({ pathParams: { teamId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"requestAccessToTeam",
		"Request access to a team as a member. An owner has to approve the request. Only 10 users can request access to a team at the same time.",
		{ teamId: requestAccessToTeamPathParamsSchema.shape["teamId"] },
		async ({ teamId }) => {
			try {
				return await requestAccessToTeam({ pathParams: { teamId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getTeamAccessRequest",
		"Check the status of a join request. It'll respond with a 404 if the request has been declined. If no `userId` path segment was provided, this endpoint will instead return the status of the authenticated user.",
		{
			userId: getTeamAccessRequestPathParamsSchema.shape["userId"],
			teamId: getTeamAccessRequestPathParamsSchema.shape["teamId"],
		},
		async ({ userId, teamId }) => {
			try {
				return await getTeamAccessRequest({ pathParams: { userId, teamId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"joinTeam",
		"Join a team with a provided invite code or team ID.",
		{ teamId: joinTeamPathParamsSchema.shape["teamId"] },
		async ({ teamId }) => {
			try {
				return await joinTeam({ pathParams: { teamId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"updateTeamMember",
		"Update the membership of a Team Member on the Team specified by `teamId`, such as changing the _role_ of the member, or confirming a request to join the Team for an unconfirmed member. The authenticated user must be an `OWNER` of the Team.",
		{
			uid: updateTeamMemberPathParamsSchema.shape["uid"],
			teamId: updateTeamMemberPathParamsSchema.shape["teamId"],
		},
		async ({ uid, teamId }) => {
			try {
				return await updateTeamMember({ pathParams: { uid, teamId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"removeTeamMember",
		"Remove a Team Member from the Team, or dismiss a user that requested access, or leave a team.",
		{
			uid: removeTeamMemberPathParamsSchema.shape["uid"],
			teamId: removeTeamMemberPathParamsSchema.shape["teamId"],
			queryParams: removeTeamMemberQueryParamsSchema,
		},
		async ({ uid, teamId, queryParams }) => {
			try {
				return await removeTeamMember({ pathParams: { uid, teamId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getTeam",
		"Get information for the Team specified by the `teamId` parameter.",
		{ teamId: getTeamPathParamsSchema.shape["teamId"], queryParams: getTeamQueryParamsSchema },
		async ({ teamId, queryParams }) => {
			try {
				return await getTeam({ pathParams: { teamId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"patchTeam",
		"Update the information of a Team specified by the `teamId` parameter. The request body should contain the information that will be updated on the Team.",
		{ teamId: patchTeamPathParamsSchema.shape["teamId"], queryParams: patchTeamQueryParamsSchema },
		async ({ teamId, queryParams }) => {
			try {
				return await patchTeam({ pathParams: { teamId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getTeams",
		"Get a paginated list of all the Teams the authenticated User is a member of.",
		{ queryParams: getTeamsQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await getTeams({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"createTeam",
		"Create a new Team under your account. You need to send a POST request with the desired Team slug, and optionally the Team name.",
		async () => {
			try {
				return await createTeam({ config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"postTeamDsyncRoles",
		"Update the Directory Sync role mappings for a Team. This endpoint allows updating the mapping between directory groups and team roles or access groups.",
		{
			teamId: postTeamDsyncRolesPathParamsSchema.shape["teamId"],
			queryParams: postTeamDsyncRolesQueryParamsSchema,
		},
		async ({ teamId, queryParams }) => {
			try {
				return await postTeamDsyncRoles({ pathParams: { teamId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"deleteTeam",
		"Delete a team under your account. You need to send a `DELETE` request with the desired team `id`. An optional array of reasons for deletion may also be sent.",
		{
			teamId: deleteTeamPathParamsSchema.shape["teamId"],
			queryParams: deleteTeamQueryParamsSchema,
		},
		async ({ teamId, queryParams }) => {
			try {
				return await deleteTeam({ pathParams: { teamId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"deleteTeamInviteCode",
		"Delete an active Team invite code.",
		{
			inviteId: deleteTeamInviteCodePathParamsSchema.shape["inviteId"],
			teamId: deleteTeamInviteCodePathParamsSchema.shape["teamId"],
		},
		async ({ inviteId, teamId }) => {
			try {
				return await deleteTeamInviteCode({ pathParams: { inviteId, teamId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"uploadFile",
		"Before you create a deployment you need to upload the required files for that deployment. To do it, you need to first upload each file to this endpoint. Once that's completed, you can create a new deployment with the uploaded files. The file content must be placed inside the body of the request. In the case of a successful response you'll receive a status code 200 with an empty body.",
		{ queryParams: uploadFileQueryParamsSchema, headers: uploadFileHeaderParamsSchema },
		async ({ queryParams, headers }) => {
			try {
				return await uploadFile({ queryParams, headers, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"listAuthTokens",
		"Retrieve a list of the current User's authentication tokens.",
		async () => {
			try {
				return await listAuthTokens({ config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"createAuthToken",
		"Creates and returns a new authentication token for the currently authenticated User. The `bearerToken` property is only provided once, in the response body, so be sure to save it on the client for use with API requests.",
		{ queryParams: createAuthTokenQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await createAuthToken({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getAuthToken",
		"Retrieve metadata about an authentication token belonging to the currently authenticated User.",
		{ tokenId: getAuthTokenPathParamsSchema.shape["tokenId"] },
		async ({ tokenId }) => {
			try {
				return await getAuthToken({ pathParams: { tokenId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"deleteAuthToken",
		"Invalidate an authentication token, such that it will no longer be valid for future HTTP requests.",
		{ tokenId: deleteAuthTokenPathParamsSchema.shape["tokenId"] },
		async ({ tokenId }) => {
			try {
				return await deleteAuthToken({ pathParams: { tokenId }, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getAuthUser",
		"Retrieves information related to the currently authenticated User.",
		async () => {
			try {
				return await getAuthUser({ config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"requestDelete",
		"Initiates the deletion process for the currently authenticated User, by sending a deletion confirmation email. The email contains a link that the user needs to visit in order to proceed with the deletion process.",
		async () => {
			try {
				return await requestDelete({ config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"createWebhook",
		"Creates a webhook",
		{ queryParams: createWebhookQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await createWebhook({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getWebhooks",
		"Get a list of webhooks",
		{ queryParams: getWebhooksQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await getWebhooks({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getWebhook",
		"Get a webhook",
		{ id: getWebhookPathParamsSchema.shape["id"], queryParams: getWebhookQueryParamsSchema },
		async ({ id, queryParams }) => {
			try {
				return await getWebhook({ pathParams: { id }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"deleteWebhook",
		"Deletes a webhook",
		{ id: deleteWebhookPathParamsSchema.shape["id"], queryParams: deleteWebhookQueryParamsSchema },
		async ({ id, queryParams }) => {
			try {
				return await deleteWebhook({ pathParams: { id }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"listDeploymentAliases",
		"Retrieves all Aliases for the Deployment with the given ID. The authenticated user or team must own the deployment.",
		{
			id: listDeploymentAliasesPathParamsSchema.shape["id"],
			queryParams: listDeploymentAliasesQueryParamsSchema,
		},
		async ({ id, queryParams }) => {
			try {
				return await listDeploymentAliases({ pathParams: { id }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"assignAlias",
		"Creates a new alias for the deployment with the given deployment ID. The authenticated user or team must own this deployment. If the desired alias is already assigned to another deployment, then it will be removed from the old deployment and assigned to the new one.",
		{ id: assignAliasPathParamsSchema.shape["id"], queryParams: assignAliasQueryParamsSchema },
		async ({ id, queryParams }) => {
			try {
				return await assignAlias({ pathParams: { id }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"listAliases",
		"Retrieves a list of aliases for the authenticated User or Team. When `domain` is provided, only aliases for that domain will be returned. When `projectId` is provided, it will only return the given project aliases.",
		{ queryParams: listAliasesQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await listAliases({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getAlias",
		"Retrieves an Alias for the given host name or alias ID.",
		{
			idOrAlias: getAliasPathParamsSchema.shape["idOrAlias"],
			queryParams: getAliasQueryParamsSchema,
		},
		async ({ idOrAlias, queryParams }) => {
			try {
				return await getAlias({ pathParams: { idOrAlias }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"deleteAlias",
		"Delete an Alias with the specified ID.",
		{
			aliasId: deleteAliasPathParamsSchema.shape["aliasId"],
			queryParams: deleteAliasQueryParamsSchema,
		},
		async ({ aliasId, queryParams }) => {
			try {
				return await deleteAlias({ pathParams: { aliasId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"patchUrlProtectionBypass",
		"Update the protection bypass for the alias or deployment URL (used for user access & comment access for deployments). Used as shareable links and user scoped access for Vercel Authentication and also to allow external (logged in) people to comment on previews for Preview Comments (next-live-mode).",
		{
			id: patchUrlProtectionBypassPathParamsSchema.shape["id"],
			queryParams: patchUrlProtectionBypassQueryParamsSchema,
		},
		async ({ id, queryParams }) => {
			try {
				return await patchUrlProtectionBypass({ pathParams: { id }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getCertById",
		"Get cert by id",
		{ id: getCertByIdPathParamsSchema.shape["id"], queryParams: getCertByIdQueryParamsSchema },
		async ({ id, queryParams }) => {
			try {
				return await getCertById({ pathParams: { id }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"removeCert",
		"Remove cert",
		{ id: removeCertPathParamsSchema.shape["id"], queryParams: removeCertQueryParamsSchema },
		async ({ id, queryParams }) => {
			try {
				return await removeCert({ pathParams: { id }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"issueCert",
		"Issue a new cert",
		{ queryParams: issueCertQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await issueCert({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"uploadCert",
		"Upload a cert",
		{ queryParams: uploadCertQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await uploadCert({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"listDeploymentFiles",
		"Allows to retrieve the file structure of the source code of a deployment by supplying the deployment unique identifier. If the deployment was created with the Vercel CLI or the API directly with the `files` key, it will have a file tree that can be retrievable.",
		{
			id: listDeploymentFilesPathParamsSchema.shape["id"],
			queryParams: listDeploymentFilesQueryParamsSchema,
		},
		async ({ id, queryParams }) => {
			try {
				return await listDeploymentFiles({ pathParams: { id }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getDeploymentFileContents",
		"Allows to retrieve the content of a file by supplying the file identifier and the deployment unique identifier. The response body will contain a JSON response containing the contents of the file encoded as base64.",
		{
			id: getDeploymentFileContentsPathParamsSchema.shape["id"],
			fileId: getDeploymentFileContentsPathParamsSchema.shape["fileId"],
			queryParams: getDeploymentFileContentsQueryParamsSchema,
		},
		async ({ id, fileId, queryParams }) => {
			try {
				return await getDeploymentFileContents({ pathParams: { id, fileId }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"getDeployments",
		"List deployments under the authenticated user or team. If a deployment hasn't finished uploading (is incomplete), the `url` property will have a value of `null`.",
		{ queryParams: getDeploymentsQueryParamsSchema },
		async ({ queryParams }) => {
			try {
				return await getDeployments({ queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);

	server.tool(
		"deleteDeployment",
		"This API allows you to delete a deployment, either by supplying its `id` in the URL or the `url` of the deployment as a query parameter. You can obtain the ID, for example, by listing all deployments.",
		{
			id: deleteDeploymentPathParamsSchema.shape["id"],
			queryParams: deleteDeploymentQueryParamsSchema,
		},
		async ({ id, queryParams }) => {
			try {
				return await deleteDeployment({ pathParams: { id }, queryParams, config });
			} catch (error) {
				return { isError: true, content: [{ type: "text", text: JSON.stringify(error) }] };
			}
		},
	);
}
